
#define _CRT_SECURE_NO_WARNINGS 1
#include <string.h>
#include <stdio.h>


//1.函数是什么
//2.库函数
//3.自定义函数
//4.函数参数
//5.函数调用
//6.函数的嵌套调用和链式访问
//7.函数的声明和定义
//8.函数递归



//====================1.函数是什么=============================
//函数一次只能返回一个值。但你可以通过其他方式来实现返回多个值的效果，比如使用指针或结构体。
//C语言函数简介
//在C语言中，函数是一组封装在一起的用于完成特定任务的代码块。函数是程序结构化的重要基础，可以提高代码的可读性、可维护性和可复用性。
//
//C语言函数的特点：
//具有返回值：C语言函数可以具有返回值，也可以没有返回值。函数的返回值是函数执行的结果。
//可以传递参数：C语言函数可以传递参数。参数是函数接收的输入数据。
//可以嵌套调用：C语言函数可以嵌套调用，即一个函数可以调用另一个函数。
//可以具有静态变量和局部变量：C语言函数可以具有静态变量和局部变量。静态变量在函数第一次被调用时分配内存，并一直存在到函数执行结束。
//局部变量在函数每次被调用时分配内存，并在函数执行结束时释放内存。
// 
//C语言函数的组成
//函数声明：函数声明用于告知编译器函数的名称、返回类型和参数列表。函数声明可以出现在函数定义之前或之后，也可以出现在其他文件的头文件中。
//函数定义：函数定义提供了函数的具体实现代码。函数定义必须包含函数名、函数参数列表、函数体和返回值。
//函数参数：函数参数是函数接收的输入数据。函数参数可以是基本数据类型、结构体、联合体或数组。
//函数返回值：函数返回值是函数执行的结果。函数返回值可以是基本数据类型、结构体、联合体或数组。



//====================函数分类=============================
//1库函数
//2自定义函数
//=========库函数是什么
//库函数（Library Function）是预先编写好的、可重用的代码块，通常存储在库文件中。
//这些函数旨在解决常见的编程任务，并提供了一种方便的方式来执行特定的操作。库函数可以包括各种功能，例如数学运算、字符串操作、文件操作等。
//=========常用库函数
//输入输出函数（stdio.h）：
//printf：格式化输出函数，用于向标准输出流打印输出。
//scanf：格式化输入函数，用于从标准输入流读取输入。
//字符串处理函数（string.h）：
//strcpy：字符串拷贝函数，用于将一个字符串复制到另一个字符串中。
//strlen：字符串长度函数，用于获取字符串的长度。
//strcmp：字符串比较函数，用于比较两个字符串是否相等。
//内存管理函数（stdlib.h）：
//malloc：动态内存分配函数，用于分配指定大小的内存块。
//free：释放内存函数，用于释放之前分配的内存块。
//数学函数（math.h）：
//sin、cos、tan：三角函数，用于计算正弦、余弦和正切值。
//sqrt：平方根函数，用于计算一个数的平方根。
//pow：幂函数，用于计算一个数的指定次幂。
//文件操作函数（stdio.h）：
//fopen、fclose：文件打开和关闭函数，用于打开和关闭文件。
//fread、fwrite：文件读取和写入函数，用于从文件读取数据和向文件写入数据。
//
//尝试自学库函数 strcpy
//函数名： strcpy
//头文件： <string.h>
//功能： 复制字符串
//语法结构：
//char* strcpy(char* dest, const char* src);
//参数：
//dest：目标字符串的指针，存放复制后的字符串。
//src：源字符串的指针，待复制的字符串。
//返回值：
//strcpy 函数返回目标字符串 dest 的指针，即源字符串复制后的字符串。


//int main()
//{
//	char arr1[20] = { 0 };
//	char arr2[] = "hunayingguanglin";
//	strcpy(arr1, arr2); //字符串拷贝,把arr2拷贝到arr1   strcpy 函数会复制整个字符串，包括结尾的空字符。
//	printf("%s\n", arr1);
//
//	//Memory Set  内存设置
//	memset(arr1, "a", 10);//注意 这样是不对的,因为是字符类型
//	memset(arr1, 'a', 10);//将数组 arr1 的前 10 个元素的值都设置为字符 'a'  默认从索引0开始 通过内存地址方式来设置内存块的内容
//					      //memset 函数本身并不知道数组的索引。它只接受一个指向内存块的指针和要设置的字节数作为参数。
//	//memset(arr1+6, 'a', 5); //表示将数组 arr1+6偏移量 中从索引为6的元素开始的连续5个元素的值设置为字符 'a'
//	printf("%s\n", arr1);
//
//	return 0;
//}
//注意
//"a"：双引号括起来的是字符串常量，表示包含单个字符 'a' 和一个字符串结束符 '\0' 的字符数组。字符串常量的类型是 char* ，即指向字符数组的指针。
//'a'：单引号括起来的是字符常量，表示一个单个的字符 'a'。字符常量的类型是 char。


//================自定义函数(函数像加工工厂一样,把原材料送进去(传参),经过加工(函数体),输出一个产品(返回值))
//如果库函数能干所有的事情，那还要程序员干什么？ 
//所有更加重要的是自定义函数。自定义函数和库函数一样，有函数名，返回值类型和函数参数。
//但是不一的是这些都是我们自己来设计。这给程序员一个很大的发挥空间
//语法结构:
// 函数声明（可选）
//返回类型 函数名(参数列表);
            //函数体
// 函数定义
//返回类型 函数名(参数列表) {
    // 函数体
//}

//自定义函数 比大小
//int 比大小(int x, int y)  //有返回值类型int  参数类型要保持一致,变量名可以随意
//{
//    //int c = 0;
//    //c = (x > y) ? x : y; //三木操作符 如果x大于y，则c等于x，否则等于y
//    return (x > y) ? x : y; //这样写更简洁,直接把结果赋值给 return
//                            //将三目运算符的结果作为函数的返回值。
//}
//
////写一个函数可以找出两个整数中的最大值.=============================
//int main()
//{
//    //定义两个变量
//    int a = 0;
//    int b = 0;
//    //输入
//    scanf("%d %d", &a, &b);//变量类型要记得取地址  注意输入格式,要原样输入,这里用的是空格来隔开两个%d 输入的时候也要用空格隔开
//    //调用函数
//    int 结果 = 比大小(a, b);
//    //输出结果
//    printf("这个值最大:%d", 结果);
//    return 0;
//}
//如果 return 后面有表达式，那么这个表达式的值将作为函数的返回值返回给调用者。
//如果是viod没返回值,return;可写可不写 
// 
//形参,实参的概念.
//形参是函数定义中用来表示函数接受的参数的变量名，而实参是函数调用中传递给函数的具体值。
//在函数调用时，实参的值将被传递给对应的形参，从而被函数使用。


//写一个函数可以交换两个整形变量的内容================================
//杯子交换法??
//可以想象成酱油和醋交换,交换过程需要有个空瓶子来引导,先将酱油放空瓶子,在把醋放酱油里,在把酱油放醋里.达到交换目的.
//其实核心目的就是,我两个值交换,无论是a=b 还是b=a 都会丢失一个目标值,所以需要一个第三者先复制一个值.

//错误的写法  (要使用不带返回值的函数)
//int 交换(int x, int y)
//{
//    //交换逻辑,通过一个空值来接收第一个变量.
//    int z = 0;
//    z = x;
//    x = y;
//    y = z;
//    return x, y;  //函数一次只能返回一个值. 多个值需要使用指针,或者结构体.
//}
//
//int main()
//{
//    //提示信息
//    printf("请输入两个数值：\n");
//    //获取输入,并输出
//    int a = 0;
//    int b = 0;
//    scanf("%d %d", &a, &b);
//    printf("交换前的a=%d  交换前的b=%d\n", a, b);
//    //交换数值
//    交换(a,b);
//    //输出
//    printf("交换后的a=%d  交换后的b=%d\n", a, b);
//    return 0;
//}
//总结一下,在主函数中的ab是实参,而在自定义函数中的xy是形参,  相当于ab的副本. 它们的内存地址是不同的.
//这段代码中的错误在于函数 交换 的返回值类型应为 void，因为它并不需要返回任何值，而是要通过引用传递修改实参的值。
//此外，函数调用时，传递的是实参的值，而不是实参本身的内存地址，因此在函数内部对形参的值进行修改，并不会影响到实参的值。
//如果带返回值函数,也只有一个返回值.因此为了实现交换功能，可以使用指针或者结构体等方法来传递多个值。
//





////正确的写法 使用指针变量
//void 交换(int* x, int* y)//在这里，int* x 和 int* y 定义了两个指针变量，它们分别指向整数类型的数据。
//                         //这意味着在函数内部，x 和 y 存储的不是实际的整数值，而是整数变量的地址。
//
//{
//    
//    int z = *x; //这一行中的 *x 是一个解引用操作符，它表示取出 x 指针所指向的地址处存储的值。然后将这个值赋给了一个普通的整型变量 z。所以这一行将 x 指针指向的整数值赋给了 z。
//    *x = *y; //这一行中的* x 和* y 是两次解引用操作，它们分别表示取出 x 和 y 指针所指向的地址处存储的值。然后通过赋值操作，将 y 指针指向的值赋给了 x 指针指向的位置。这样就完成了将 x 指针指向的值替换为 y 指针指向的值的操作。
//    *y = z;
//}
//
//int main()
//{
//    //提示信息
//    printf("请输入两个整数");
//    //获取输入
//    int a = 0;
//    int b = 0;
//    scanf("%d %d", &a, &b);
//    printf("交换前的a=%d  交换前的b=%d\n", a, b);
//    //调用交换函数
//    交换(&a, &b);  //将ab变量内存地址传递给"交换"函数
//    //输出
//    printf("交换后的a=%d  交换后的b=%d\n", a, b);
//    return 0;
//}

//正确的写法 使用结构体通过多个成员变量,使得返回结构体来返回多个相关联的成员变量.实现了返回多个参数的特点, 避免了函数只有一个返回值的特点.
//自定义结构体     //结构体特点,可以返回多个参数
//struct my结构体  //需熟练掌握结构体语法结构..
//{
//    int 交换a;
//    int 交换b;
//};
//
////自定义函数交换
//struct my结构体 交换(int x, int y)  //如果要在函数中使用结构体类型作为参数或返回值，需要在函数声明和定义中使用一致的结构体类型。
//{
//    struct my结构体 shuru;
//    shuru.交换a = y;
//    shuru.交换b = x;
//    return shuru;
//}
//
////主函数
//int main()//一定要先检查这里是不是拼错了main
//{
//    //提示信息
//    printf("输入两个整数");
//    //获取输入
//    int a = 0;
//    int b = 0;
//    scanf("%d %d", &a, &b);//注意 别忘了取地址..
//    printf("交换前的a=%d  交换前的b=%d\n", a, b);
//    //调用函数
//    struct my结构体 jieguo = 交换(a, b);
//    //输出
//    printf("交换前的a=%d  交换前的b=%d\n", jieguo.交换a, jieguo.交换b);
//    return 0;
//}
//结构体在C语言中是一种自定义数据类型，用于组合不同类型的数据成员。因此，在使用结构体时，需要保持一致的数据类型，包括创建变量、定义函数、声明类型和访问结构体成员等方面。
//具体来说：
//创建变量：使用 struct 结构体名 变量名; 的语法来创建结构体变量。例如，如果结构体名是 Student，则创建一个名为 student1 的变量可以写作 struct Student student1; 。
//定义函数：如果要在函数中使用结构体类型作为参数或返回值，需要在函数声明和定义中使用一致的结构体类型。
//自定义结构体的一个重要特点是能够返回多个数值，这主要是因为结构体可以包含多个成员变量，每个成员变量都可以存储不同类型的数据。
//这使得函数可以通过返回一个结构体来返回多个相关联的数值，而不仅仅是返回单个数值。这种特性在需要返回多个相关联的数据时非常实用，可以简化代码并提高程序的可读性和可维护性。


//main()函数有且仅有一个,程序的唯一入口.  可以有多个.c源文件,但是mian()只能有一个.

//4.===============================函数参数=========================
//当实参传递给形参的时候,形参实际上是实参的一份临时拷贝.
//对形参的修改,不能改变实参.

//?什么情况下不用传地址,什么情况下要传地址.
//函数不对实参进行修改,则不需要传变量的地址. 让形参与实参建立联系  (可以理解成对实参有读写操作)
//函数对实参进行修改,则需要传送变量的地址. (可以理解成对实参有只有读取的操作)

//?交换两个变量的地址,会改变它们的值吗?
//C语言变量地址通常是不可以修改的,在编译时就确定好了,所以两个变量互换内存地址是不好实现的,容易产生错乱
//但是，你可以通过传递指向指针的指针或者使用引用来实现这一目的。
//交换两个变量的地址并不会改变它们的值。地址是指变量在内存中的位置，而值是存储在这些位置上的数据。
//交换地址只是将变量所在的内存位置互换了一下，但实际存储在这些位置上的值并没有改变。要交换变量的值，你需要通过操作它们的值而不是地址。

//实际参数(实参)================
//真实传给函数的参数, 叫实参.
//实参可以是:常量, 变量, 表达式, 函数等.
//无论实参是何种类型的量, 在进行函数调用时, 它们都必须有确定的值, 以便把这些值传递给形参.
//形式参数(形参)================
//形式参数是指函数名后圆括号中的变量, 因为形式参数只有在函数被调用的过程中猜实例化(分配内存单元),
//所以叫形式参数, 形式参数当函数调用完成之后就自动销毁了.因此形式参数只在函数中有效.


//================================5.函数调用================================
//传值调用================
//  函数的形参和实参分别占有不同内存块,对形参的修改不会影响实参.
//传址调用================
//  传址调用是把函数外部创建变量的内存地址传递给函数参数的一种调用函数的方式.
//  这种传参方式可以让函数和函数外边的变量建立起真正的联系,也就是函数内部可以直接操作函数外部的变量.
// 

//void 自定义函数1(int x, int y)
//{
//    ;//传值调用函数的变量只是ab的临时拷贝
//     //修改形参的值不会影响实参.
//}
//void 自定义函数2(int* x, int* y)//形参的指针变量存的是来自于实参a,b变量的内存地址.
//{
//    ;//传址调用让函数和函数外边的变量建立起真正的联系,可在函数内影响实参.
//}
//
//int main()
//{
//    int a = 0;
//    int b = 0;
//    //实参---实际参数
//    自定义函数1(a, b); //传值调用
//    自定义函数2(&a, &b);//传址调用
//    return 0;
//}


//=====================================练习=================================================
//1.写一个函数可以判断一个数是不是素数
//2.写一个函数判断一年是不是闰年
//3.写一个函数,实现一个整形有序数组的二分查找
//4.写一个函数,每次调用这个函数,就将num的值增加1

//1.写一个函数可以判断一个数是不是素数=================================================
// 素数也叫质数
//素数就是大于1的自然数，它只能被1和自己整除
//复习打印100~200之间的素数  版本1未优化
//int main()
//{
//    // 主函数，程序入口
//
//    // 通过for循环生成100~200的质数
//    int i = 0;
//    int 总数 = 0;  // 计数器，用于记录质数的个数
//    for (i = 100; i <= 200; i++)
//    {
//        int er = 0;  // 用于判断i是否为质数的标记变量
//        int x = 1;    // 初始假设i是质数
//        for (er = 2; er <= i - 1; er++)
//        {
//            if (i % er == 0)
//            {
//                x = 0;   // i能被整除，不是质数
//                break;
//            }
//        }
//        if (x == 1)
//        {
//            printf("%d ", i); // 输出质数
//            总数++;          // 质数个数加一
//        }
//    }
//    printf("\n%d", 总数);  // 输出质数个数
//    return 0;
//}

//复习打印100~200之间的素数  版本2优化
//sqrt 是C语言中的数学函数，用于计算一个数的平方根。
//这个函数位于 math.h 头文件中，并且返回一个浮点数类型的结果。
#include <math.h>
//int main()
//{
//     //素数总数:
//    int zongshu = 0;
//    //首先产生100~200之间的数
//    int shu = 0; //初始化数作为循环条件
//    for (shu = 101;shu<=200; shu+=2) //循环从101开始,每次加2直到200.  //注意表达式 ,shu+2,这是一个表达式，表示将变量 shu 的值与2相加，但并不改变 shu 的值本身。
//                                     //shu += 2：这是一个复合赋值运算符，表示将变量 shu 的值增加2，然后将结果赋值给 shu。这等同于 shu = shu + 2。简而言之，它是对变量 shu 的值进行修改，使其增加了2。
//    {                                //偶数都不是素数,除了2, 这里从101开始每次+2跳过偶数,简洁缩小判断范围,直接省去了一半的判断数
//        //判断数变量是不是素数
//        int biaoji = 1;//假设默认是素数. 也充当一个开关作用的变量.
//        //初始化一个变量,从2开始
//        int er = 0;
//        //遍历2到开平方shu,之间.
//        for (er = 2; er <= sqrt(shu); er++) //因为素数只能是1和本身能整除,所以要从2开始进行整除运算.
//        {                                   //又因为非素数可以被多个不同的正整数整除,那么反过来,它们的关系就是x=a*b   例如16=2*8   16=4*4 
//                                            //带入到我们的代码就是 数=a*b , 这样的话我们进行开平方操作,假设 16开平方=4*4
//                                            //a*b 这两个数一定又一个数小于等于16的平方根.
//                                            //所以代码er变量从2开始进行整除操作. 因此经过开平方的方式,缩小了循环次数,使得执行效率提升 
//            if (shu % er == 0) //% 表示取余运算，即计算 数 除以 er 的余数。
//            {
//                //int biaoji = 0;//不要在变量前面乱加int ..导致出错
//                biaoji = 0; //if判断成立,说明是非素数. 设置标记为0;
//                break;      
//           
//            }   
//        }
//        if (biaoji == 1)//因为初始化我就设置默认为1 ,假设是一个非素数.
//        {
//            printf("%d ", shu);
//            zongshu++;
//        }
//    }
//    printf("\n%d", zongshu);
//    return 0;
//}
//对于一个非素数（合数）x，如果能够找到两个正整数a和b，使得x = a * b，并且a和b中
//至少有一个小于或等于x的平方根，那么我们可以通过遍历1到x的平方根来找到a和b。
//对于16这个例子，16的平方根是4。因此，我们只需要在1到4之间搜索a的可能取值，如果
//找到a的值使得16能够被a整除，那么b就是16除以a的商。在这种情况下，a和b可能是4和4，也可能是2和8，这取决于我们的搜索顺序。


//复习打印100~200之间的素数  版本3 使用函数调用
// 判断一个数是否为素数的函数
//int Sushu(int x)
//{
//    int er = 0;
//    // 从2开始，到 x 的平方根结束，逐个检查是否能整除 x
//    for (er = 2; er <= sqrt(x); er++)
//    {
//        if (x % er == 0)
//        {
//            return 0; // 如果能整除，说明不是素数，返回0
//           //break; // break只是跳出循环,而return只要执行了就直接结束函数. 比break更有效,或者说是更高的权限.
//        }
//    }
//    return 1; // 如果上面条件不成立，说明是素数，返回1
//}
//
//int main()
//{
//    int zongshu = 0; // 记录素数的个数
//    int shuzhi = 0;
//    // 生成100~200之间的奇数
//    for (shuzhi = 101; shuzhi <= 200; shuzhi += 2)
//    {
//        if (Sushu(shuzhi)) // 这里还是要注意,这个函数调用是在if语句下的表达式中实现的,返回值1 可以使得if语句为真,0为假
//        {
//            printf("%d ", shuzhi); // 输出素数
//            zongshu++; // 素数个数加1
//        }
//    }
//    printf("\n%d", zongshu); // 输出素数的个数
//    return 0;
//}
//在 Sushu 函数中，通过循环从2开始到 x 的平方根结束，逐个检查是否能整除 x。
//如果找到能整除 x 的数，则说明 x 不是素数，返回0；如果循环结束都没有找到能整除 x 的数，则说明 x 是素数，返回1。
//
//在 main 函数中，从101开始每次增加2，即遍历100到200之间的奇数。对于每个奇数，调用 Sushu 函数判断是否为素数，
//如果是素数则输出，同时计数器加1。最后输出素数的个数

//函数的功能尽量保证单一性,独立性,方便各种场景的调用.
//高内聚低耦合



//12.输出1000~2000闰年=================================================
//具体算法为：1.如果年份能被 4 整除但不能被 100 整除，那么这一年是闰年。2.如果年份能被 400 整除，那么这一年也是闰年。

//计算闰年函数  ===未简化算法.
//int 闰年(int x)
//{
//    if (x % 4==0)  //因为能整除的话是没有余数的,所以用取余% 就可以判断除是否能整除.
//        if (x % 100 != 0)
//        {
//            return 1;
//        }
//    if (x % 400 == 0)
//    {
//        return 1;
//    }
//    return 0;
//}

//闰年计算函数, 简化算法
//int 闰年(int x)  //函数的功能要单一,模块化,就是做一件事,不能既要又要
//{
//    if (((x % 4 == 0) && (x % 100 != 0)) || (x % 400 == 0)) //通过与或非连接符,把公式连接起来,简化代码
//        return 1;
//    else
//        return 0;
//}
//
//int main()
//{
//    //先通过循环得到1000`2000年
//    int year = 0;
//    //函数返回结果变量
//    int 结果 = 0;
//    for (year = 1000; year <= 2000; year++)
//    {
//        //调用函数计算润year
//        //结果 = 闰年(year);  //可以简化
//        //if (结果)
//        //{
//        //    printf("%d:是闰年 ", year);
//        //}
//        // 
//        //简化代码
//        if (闰年(year))//函数是int返回类型, return 1 和0 ,通过1和0可以使得if语句是否为真.
//        {
//            printf("%d:是闰年 ", year);
//        }
//    }
//    return 0;
//}

//13.使用二分查找函数=================================================
//int 二分查找(int arr[], int x, int y)  //arr 这里的arr是指向数组首元素的指针 . 是个指针,给他[]中的值 就会对应索引内的数值
//{
//    int 左边 = 0;//左边界 ,因为元素下标0开始
//    int 右边 = y - 1;//右边界,总个数减1,因为元素下标0开始
//    while(左边<=右边)
//    { 
//        int z = 左边 + ((右边 - 左边) / 2);
//        if (arr[z]==x)  //在 二分查找 函数中，arr[] 是指向数组首元素的指针，通过 arr[z] 可以访问数组中索引为 z 的元素的值。
//        {
//            return z;
//        }
//    
//        if (arr[z] < x)  
//        {
//            左边 = z+1;  //更新的是数值,不是数组索引..
//        }
//
//        else
//        {
//            //右边= arr[z]-1; //注意不要混淆, z已经是索引了,因为它将右边界更新为当前中间位置的值减去1，而不是索引减去1。
//            右边 = z - 1;
//        }
//    }
//    return -1;//因为数组下标是0 ,所以不能返回0  使用-1来表示找不到.
//}
//
//int main()
//{
//    //有序数组
//    int arr[] = { 0,1,3,5,7,8,9,11 };  //arr[]看上去是数组，本质是指针变量 等价于int *arr   数组名会被隐式转换为指向数组首元素的指针
//    //输入一个要查找的值
//    //int 输入=scanf("%d", &输入);//这样写不对,scanf 函数会返回成功读取并赋值的参数个数，如果成功读取了一个整数，则返回1，否则返回0
//    int 输入 = 0;
//    scanf("%d", &输入);//这样才可以把输入的内容赋值到变量. 因为scanf是函数有返回值.
//    //二分查找算法函数 --返回元素下标
//    //需要数组元素个数两个边界和一个中间值
//    int 个数 = sizeof(arr) / sizeof(arr[0]);//元素个数   注意 sizeof(arr) 这个表达式是计算数组总字节大小.
//    //调用函数,并传参
//    int 结果 = 二分查找(arr, 输入, 个数);//注意函数返回值跟传参的这几个没关系,函数返回值是另外一个东西,是个结果 具体某个值
//    if (结果 == -1)
//    {
//        printf("找不到");
//    }
//    else
//    {
//        printf("找到了他的下标是:%d 他的值是%d", 结果, arr[结果]);
//
//    }
//    return 0;
//}
//在C语言中，当你传递一个数组给函数时，实际上传递的是数组的首个元素的地址。
//换句话说，传递的是数组的指针。因此，函数中接收到的参数是指向数组首元素的指针，而不是整个数组。
//数组名本身就是数组首元素的地址。因此，在传递数组给函数时，你不需要使用& 运算符来取数组的地址，直接使用数组名即可。
//数组名被视为指向数组首元素的指针。因此，当你在函数中传递数组名时，实际上传递的是数组的地址，即指向数组首元素的指针。
//函数调用数组的时候，传递的是数组首元素的地址，是个指针变量， 这样一来 函数就不用再重新开辟一个数组变量，造成内存的浪费。所以不要再自定义函数内计算数组元素个数.

////布尔类型
//#include <stdbool.h>
//
//int main() {
//    bool isTrue = true;
//    bool isFalse = false;
//    if (isTrue) {
//        // 这里的代码块会执行，因为 isTrue 是真
//    }
//    if (!isFalse) {
//        // 这里的代码块会执行，因为 isFalse 是假
//    }
//    return 0;
//}


//14.写一个函数每次调用num+1=================================================
//void numjia(int x) 这是错误的,这个x会生成一个随机值,因为要用解引用操作符来指向指针变量才行.
//void numjia(int *x)  
//{
//    //return x++;  //return x++; 将会先返回 x 的当前值，然后再将 x 的值增加1。 
//   // return ++x;// 无论函数返回的是一个值还是没有值（void 函数），一旦执行到 return 语句，函数的执行都会立即结束 它也不会返回任何内容。
//    (*x)++;
//}
////(*x)++：
////(*x) 表示通过指针 x 访问的变量的值。
////后置++运算符 ++ 会将该变量的值增加1。
////整个表达式的含义是，先使用指针 x 访问变量的值，然后再将该值增加1。
////该表达式并没有对指针 x 进行修改，仅修改了指针所指向的变量的值。
////return x++; ：
////x++ 中的后置++运算符表示先返回 x 的当前值，然后再将 x 的值增加1。
////整个表达式的含义是，先返回指针 x 的当前值（即指针所指向的地址），然后再将指针的值增加1。
////这种语法在 C 语言中是不合法的，因为x++ 返回的是指针的值，而 return 语句后面不能跟指针类型的表达式，应该是一个具体的值或表达式。
//int main()
//{
//    int num = 0;
//    //调用函数
//    int i = 0;
//    for (i = 0; i < 100; i++) //在 for 循环中，如果使用后置++运算符（num++），它会在每次循环迭代结束后执行，即在循环体内的语句执行完成后才会将变量的值增加1。
//    {
//        numjia(&num); //因为要对实参进行操作,所以传地址
//        printf("%d\n", num);
//    }
//
//    return 0;
//}






//======================================6.函数的嵌套调用和链式访问===================================================''
// 
// C语言的语法规定，函数的定义必须位于全局作用域或其他函数的外部。函数内部只能包含语句和局部变量的定义，不能包含函数的定义。
// 在 C 语言中，函数的声明和定义确实需要按照顺序写，因为在调用函数之前，编译器必须知道函数的原型（即函数的声明），以便正确地解析函数调用。
// 
// =====================================函数的嵌套调用
// 函数的嵌套调用是指在一个函数内部调用另一个函数，这样的调用关系可以一直嵌套下去，形成函数调用的层次结构。
// 在 C 语言中，函数的嵌套调用是一种常见的编程技巧，可以使程序更加模块化、易于理解和维护。
//// void innerFunction() {
//printf("This is the inner function.\n");
//}
//void outerFunction() {
//    printf("This is the outer function.\n");
//    innerFunction(); // 在外部函数中调用内部函数
//}
//int main() {
//    printf("This is the main function.\n");
//    outerFunction(); // 在主函数中调用外部函数
//    return 0;
//}
// 
// ======================= 链式访问
// 前提是函数要有返回值.
// 函数不写返回值类型的时候,默认是int类型.   main() 这样不加返回值类型的写法不推荐.
// 
//int main()
//{
//    int len = strlen("abcedfg");
//    printf("%d\n", len);
//    //链式访问
//    printf("%d\n", strlen("abcedfg"));  //把一个或多个函数的返回值作为一个或多个函数的参数,就是链式访问.
//    //经典链式访问.
//    printf("%d", printf("%d",printf("%d",43)));// 先打印43. 两个字符返回值2给上一个调用的函数,打印一个2,返回值作为参数给上一个,打印1  
//    //所以输出结果是4321
//    return 0;
//}
//printf 返回值：如果成功，返回输出的字符数；如果出错，返回负值。


//int 自定义函数(int x)   //自定义函数,一定要明确有没有返回值,要声明好它的类型是什么
//{
//    printf("hehhe");    
//    //如果你给自定义函数定义了返回值类型,但是你又没指定返回什么参数那么.
//    //一些编译器上返回的是函数中执行过程中最后一 条指令执行的结果 比如这个pringtf 返回结果就是5 因为printf返回值是打印的字符个数.
//}
//
//int main(void)  //这种写法意思是 明确告诉你,不要给我传参数,传了也不接.编译器也会不通过.
//{
//    return 0;
//}


// ===================================函数的声明和定义===============================================
// 函数的声明
//1.告诉编译器有一个函数叫什么，参数是什么,返回类型是什么。但是具体是不是存在，函数声明决定不了。
//2.函数的声明一般出现在函数的使用之前。要满足先声明后使用。
//3.函数的声明一般要放在头文件中的。
// 
//函数的声明  ---告诉编译器我有个自定义函数.
//------引用加法模块-------------
#include "头文件自定义函数的声明.h"  //这个头文件引用就相当于 自定义函数的声明    int jiafa(int a, int b); 
//----------------------------------
//int jiafa(int a, int b);  //这就是函数的声明,  a b 可以不写,推荐写保持一致性..  注意末尾要有分号;
//自定义函数jiafa.c 和头文件自定义函数的声明.h 这两个文件叫做一个加法模块.

//int main()
//{
//    int a = 0;
//    int b = 0;
//    scanf("%d %d\n", &a, &b);
//    int sum = jiafa(a, b);
//    return 0;
//}
//
////函数的定义.  
// 如果我就想把自定义函数写再下面,则需要在main主函数上面声明.(建议放在头文件中.)
// 函数的定义是指函数的具体实现，交待函数的功能实现。
//int jiafa(int a, int b)
//{
//    return a + b;
//}

//为什么代码不能都写在一个.c文件里???要这么费劲又声明头文件,还要单独把函数新建一个.c文件????
//在 C 语言中，你可以将所有的代码都写在一个.c 文件中，这在小型项目或者简单的练习中是可以的。但是，随着项目规模的增大以及代码的复杂性增加，将代码拆分成多个文件通常更加合适，有以下几个原因：
//模块化和可维护性： 将代码分成多个文件，每个文件负责特定的功能或模块，可以使得代码更加模块化和易于维护。每个文件只包含特定功能的代码，更容易定位和修改。
//编译效率： 当你修改了一个文件时，只需要重新编译该文件，而不需要重新编译整个项目，这可以提高编译的效率。如果所有代码都写在一个文件中，每次修改都会导致整个文件需要重新编译，耗费时间。
//团队协作： 在团队开发中，将代码分成多个文件可以更好地进行团队协作。不同的开发人员可以负责不同的文件，降低了代码冲突和合并的可能性。
//可重用性： 将代码分成多个文件可以使得某些功能或模块更容易被其他项目或者其他部分重用。你可以将一些通用的功能写成库文件，供其他项目使用。
//清晰性和结构性： 将代码分成多个文件，使得项目的结构更加清晰，有助于项目的整体设计和理解。

//就比如写个计算器 ,程序员a 来设计 加法运算,写完后 程序员a只需要 创建一个加法.c函数的实现 ,和一个加法.h 放函数的声明,就行了.
//然后在把所有模块拼接起来 .
// 
// 也可以将.c .h这个功能模块,进行静态编译成一个静态库文件.lib 以防别人直接拿到你的函数声明和函数功能的实现... 有很强的抵御反编译能力.
// https://www.bilibili.com/video/BV1Vm4y1r7jY/?p=44&spm_id_from=pageDriver&vd_source=f7ddcd601961a1fdf039e8aebf4558fa
// 
// 导入静态库.lib 文件.
//#pragma comment 是 Visual C++ 特有的一个预处理器指令，用于向编译器发出特定的链接命令。它通常用于告诉编译器将某个库文件链接到正在编译的程序中。
//#pragma comment(lib, "library_name")
// 
// 之所以能实现静态库的编译,是因为我把函数的功能分别写在了.c 函数的声明写在了.h中  方便了静态编译
// 
// 


//=============================================8.函数递归===========================================================
//https://www.bilibili.com/video/BV1Vm4y1r7jY/?p=46&vd_source=f7ddcd601961a1fdf039e8aebf4558fa
// 
//===========什么是递归？  
// 在函数内部调用自身来解决问题
// 如何理解好递归函数呢。
// 递是一个动作  递延出去
// 归是一个动作  归还回来
// 
// 递归函数的核心思想就是将问题拆解成更小的同类问题，直到达到最小规模的问题，然后通过解决这些最小规模的问题来解决原始的问题。这种思想类似于俄罗斯套娃，不断地打开套娃直到最里面的那个。
// 
//程序调用自身的编程技巧称为递归(recursion)。
//递归做为一种算法在程序设计语言中广泛应用。一个过程或函数在其定义或说明中有直接或间接调用自身的
//一种方法， 它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略.
//只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。
//递归的主要思考方式在于 : 把大事化小




//当然可以！让我们一步步地从头开始学习递归函数的逻辑。我们先从最基本的概念开始：
//
//1. 什么是递归？
//递归是指在函数的定义中使用函数自身的调用方式。这种调用方式将问题分解成更小的、相似的子问题，直到达到可以直接解决的最小子问题。
//
//2. 递归函数的基本结构
//递归函数通常具有两个部分：
//
//基本情况（Base Case）：这是递归函数中的退出条件。当满足基本情况时，递归将停止并返回一个已知的值。
//递归情况（Recursive Case）：这是递归函数中调用自身的部分。通过不断地调用自身，并且每次都解决一个更小的同类问题，最终达到基本情况。
//3. 递归函数的思考方式
//为了更好地理解递归函数，可以采用以下思考方式：
//
//假设递归函数已经可以解决更小规模的同类问题：这意味着在编写递归函数时，你可以假设自己已经具有了一个可以解决规模更小的同类问题的函数。
//考虑如何将当前问题分解成更小的子问题：思考如何将当前问题拆分成一个或多个规模更小的、同类的子问题。
//确保递归调用最终会达到基本情况：递归函数中的递归调用必须能够最终达到基本情况，否则会导致无限递归，最终耗尽内存空间。


//===========递归的两个必要条件
//存在限制条件，当满足这个限制条件的时候，递归便不再继续。
//每次递归调用之后越来越接近这个限制条件。



//*******每一次调用函数都会在栈区申请空间*****
// 死递归 错误代码 Stack overflow  栈溢出.
//必看视频<<函数栈帧的创建和销毁>>
//https://www.bilibili.com/video/BV1Pz4y1F7bU/?vd_source=f7ddcd601961a1fdf039e8aebf4558fa

//函数递归练习
//接受一个整数值(无符号),按照顺序打印它的每一位.==================
//假设 用户输入10086,,输出1  0   0   8   6

//首先分析题目,需要一个输入无符号变量
//输入内容的处理, 怎样把1234这个整数拆分成1,0,0,8,6
//输出.
//int main()   //拆分步骤,梳理过程.
//{
//    //储存输入的内容 ,注意是无符号整型
//    unsigned int shuru = 0;
//    scanf("%d", &shuru);
//    //拆分这个值
//    // shuru % 10; 如果直接进行取余运算,会改变变量的值,所以我使用打印函数,用表达式的方式得到个位数,这样可避免改变变量的值
//    printf("%d ", shuru % 10);   //通过取余,得到输入的末尾数字如10086 ÷ 10 = 1008 余 6
//                                 //为什么要%10呢,如果我们想要获取整数的每一位数字,当我们对一个整数进行 % 10 运算时，得到的结果就是这个整数的个位数字。
//                                 //而如果想要获取整数的后两位数字，可以使用 % 100
//    //shuru / 10;这样是不对的,这是个计算表达式,并不是赋值
//    shuru=shuru / 10;  //因为是无符号整型,所以是非负数,没有小数点部分,会被省去.  得到1008
//    printf("%d ", shuru % 10); //1008 ÷ 10 = 1000 余 8
//    shuru = shuru / 10; //得到100
//    printf("%d ", shuru % 10); //100 ÷ 10 = 100 余 0
//    shuru = shuru / 10; //得到10
//    printf("%d ", shuru % 10); //10 ÷ 10 = 1 余 0
//    shuru = shuru / 10;//得到1
//    printf("%d ", shuru % 10); //1 ÷ 10 = 1 余 1
//    //通过取余和除法运算,我们可以把输入的数值进行拆分,并按照顺序输出.
//    //进一步处理可以使用递归函数方式来处理.
//    return 0;
//}


//使用递归函数方式 
//void digui(unsigned int x)
//{
//    //基本情况-递归退出条件
//    if (x > 9)   // 当用户输入的值 小于9 说明是个位数了,
//    {
//        //递归情况-调用自身,每次调用都接近递归退出条件
//        digui(x / 10);  //先处理高位数字，再处理低位数字
//    }
//    printf("%u ", x % 10);//这个打印是先从高位数打印的,如果倒叙可以写在判断的上面,这样就是从地位开始打印.
//
//}
//int main()
//{
//    //获取输入
//    unsigned int shuru = 0;
//    scanf("%u", &shuru); //%u表示无符号整型
//    //函数调用
//    digui(shuru);
//    return 0;
//}

//假设用户输入的数字是 1234。
//首先，函数 digui(1234) 被调用。
//在函数内部，我们检查输入的数字是否大于 9。是的，1234 大于 9，所以我们进入了递归情况。
//我们将 1234 除以 10，得到 123。这是一个更小的问题，我们需要打印出 123 的个位数。
//然后，我们再次调用 digui(123)。
//在新的函数调用中，我们检查输入的数字是否大于 9。是的，123 大于 9，所以我们继续递归。
//我们将 123 除以 10，得到 12。我们需要打印出 12 的个位数。
//再次调用 digui(12)。
//依次类推，我们继续递归，直到输入的数字变成了个位数，即小于等于 9。
//当输入的数字为个位数时，递归不再继续，而是直接打印出这个个位数。
//递归结束，从最内层的递归开始，依次回溯到外层递归，打印出每一位数字。


//16.不使用临时变量,计算字符串长度 递归函数===============================
//相当于我们自己设计一个 sizeof()函数.
//int 求字符串长度(char* arr)   //使用临时变量写法  
//{
//    int p = 0;
//    //基本情况,递归的终止条件
//    while (*arr != '\0')
//    {
//        arr++;  //为什么是arr++?? 因为他是char类型       arr++ 操作会使指针 arr 指向下一个 char 类型的地址。因为 arr 是一个 char 类型的指针，所以 arr++ 操作会使指针向后移动一个 char 类型的长度，即移动到下一个字符的地址。
//                //如果 arr 是指向其他类型（如 int、float、double 等）的指针，那么 arr++ 将根据所指向的类型的大小进行移动。
//                //例如，如果 arr 是一个 int 类型的指针，那么 arr++ 将使指针指向下一个 int 类型的地址，即增加 4 个字节（假设 int 类型占据 4 个字节）。
//        p++;
//    }
//    return p;
//}
//在函数参数中，int arr[] 和 int* arr 是等价的，都表示一个指向整型数组的指针。
//int arr[]：在函数参数中，int arr[] 表示接受一个整型数组作为参数。
//int* arr：在函数参数中，int* arr 表示接受一个指向整型数组首元素的指针作为参数。
//参数可以写成 int arr[] 或 int *arr，效果是一样的，都表示接受一个整型数组作为参数。


//str++ 通常用于迭代数组或字符串中的元素，而 str + 1 通常用于计算指向数组或字符串中下一个元素的地址，但不改变原始指针的值。


//int 求字符串长度(char* caa)  //不适用临时变量,递归方式
//{
//    //过程拆解   假设用户输入abcdef  判断条件不为空\0  
//    //求字符串长度(abcdef)
//    //1+求字符串长度(bcdef)       1就是第一次判断进来 a
//    //1+1+求字符串长度(cdef)
//    //1+1+1+求字符串长度(def)
//    //1+1+1+1+求字符串长度(ef)
//    //1+1+1+1+1+求字符串长度(f)
//    //1+1+1+1+1+1+求字符串长度(\0)
//    //1+1+1+1+1+1+0=6
//    if (*caa != '\0')
//    {
//       return 1 + 求字符串长度(caa + 1);   //caa+1 得到下个元素的地址.
//       //(caa + 1) 是指针 caa 的值加上指针指向的类型的大小的增量。移动一个 int 类型的指针时，它会使指针向后移动4个字节
//       //这个递归函数就是条件成立就返回1 ,直到遇到\0停下来,把每次自身调用成立的部分值为1,然后在层层累加起来.
//       //当你对一个表达式困惑或者不确定时候,一定要想一想这个是不是变量,它的类型,它的返回值等,就好比caa+1  caa  表示一个指向某种类型的数据的指针 +1就是下一个元素   
//    }
//    else
//    {
//        return 0;
//    }
//
//}
//递归函数,就是先通过约束条件进行一步一步调用自身到最底层,直到不满足条件后,再从底层把值层层返回.
//要注意的是函数自身调用的时候,会从函数名字开始执行.并不是某段代码.同时每次的自身调用都会有函数参数的变动.和返回值的变动.

//递归设计和其他语句设计时候,不要过于死板,要擅长利用计算表达式来处理逻辑,可以无中生有比如 1+x ;即使不用变量,也可以做很多的运算.
//计算 abcd字符串长度,其实就是依次计算, 先把a拿出来,设计一个函数返回值,把整体拆分成有调理的个体.
//int main()
//{
//    //获取用户输入
//    char arr[20] = { 0 };
//    scanf("%s", arr);
//    printf("%s\n", arr);
//    //求字符串长度自定义函数
//    int len=求字符串长度(arr);
//    printf("%d", len);
//
//    return 0;
//}
//scanf是个字符串  怎么储存到char 数组中的呢????
//举个例子，如果用户输入了字符串 "Hello"，scanf 函数会将 'H' 存储到 arr[0]，
//'e' 存储到 arr[1]，'l' 存储到 arr[2]，'l' 存储到 arr[3]，'o' 存储到 arr[4]，
//然后在 arr[5] 的位置存储空字符 '\0'，以表示字符串的结束。
//scanf 函数的工作方式是根据格式说明符来进行数据的读取和格式化，而不是直接与数组的类型相关联。
//所以，无论是% s 还是% d，都可以将读取到的数据存储到相应的变量中，只要变量的类型与格式说明符相匹配即可。


//============================递归与迭代==========================================
//迭代就是重复


//===============练习求N的阶乘  ，递归 与 迭代
//阶乘： 正整数的积 ，并且有0的阶乘为1
// n*(n-1)!   例如 5!=5*4*3*2*1   


//int jiecheng(int shuru)  //递归的实现方法
//{
//    //if (shuru > 0)  //这样写不太对,如果输入负数会导致死递归.需要多加考虑
//    if (shuru <= 0)
//        return  1;
//    else
//        // return shuru* jiecheng(shuru - 1); //将公式套用过来即可实现递归.
//        //或者使用三目操作符
//        return shuru <= 0 ? 1 : shuru * jiecheng(shuru - 1);  //在条件运算符中，1 是一个常量值，表示条件为真时要返回的结果。三元运算符是具有返回值的。
//}

//int jiecheng(int shuru)  //迭代的实现方法(非递归) 使用循环方式
//{
//    //初始值
//    int i = 0;  
//    int r = 1; // i 和 r，分别用来迭代循环的计数器和保存阶乘的结果。
//    for (i = 1; i <= shuru; i++)
//    {
//        //r =  i * shuru;错误的  r=1*5  r=2*5  r=3*5  r=4*5  r=5*5   结果是25
//        r = r * i; // r=1*1 r=1*2 r=2*3 r=6*4 r=24*5  结果120
//        //这里 i对应的就是输入,通过循环i每次自增. 自增过程每次乘的结果赋值给r 这个过程是把每次阶乘的结果给了r   .
//    }
//    return r;
//}
//
//int main()
//{
//    //获取输入
//    int shuru = 0;
//    scanf("%d", &shuru);
//    //调用阶乘函数 
//    int jieguo=jiecheng(shuru);
//    printf("%d的阶乘:%d",shuru,jieguo);
//    return 0;
//}
//阶乘理解的还是有点绕脑子,需要慢慢建立思维..


//=================18.求第n个斐波那契数  递归 与 迭代
//斐波那契数列定义: 假设第0项和第1项分别为3和4。从第2项开始，每一项都是前两项的和。7
//0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987  注意斐波那契数列是从0项开始的, 0就是0项,1是1项,2是3项
//F0 = 0
//F1 = 1
//Fn = Fn - 1 + Fn - 2, n > 1  ;这是 斐波那契数列的递推公式
//在数学中，f0、f1和fn通常指的是斐波那契数列中的数。斐波那契数列是一种递增数列，其中每个数是前两个数的和，除了第一个和第二个数是固定的值。

//int fbn(int sc) //使用递归实现
//{
//   // if (sc<=2)  //因为斐波那契数列从第二项开始取前两位数的和. 第0项是f0=0  第1项是f1=1  第2项是f2=f0+f1=1 所以fn小于2就给它返回1就行了.
//                  //如果使用 fn < 2 就给它返回 1 的方法来判断斐波那契数列中的某个项，那么对于第 0 项 f0，会返回错误的结果。
//    if (sc == 0)
//        return 0;
//    else if(sc<2)
//        return 1;
//    else
//        return fbn(sc-1)+fbn(sc-2);//套用斐波那契数列公式,这个递归函数,调用了两次递归自身.
//
//}
//性能问题：递归调用函数会增加函数调用栈的深度，而函数调用栈是有限的。当递归深度过大时，可能导致栈溢出（stack overflow），尤其是对于大型输入。
//内存消耗：递归调用会消耗额外的内存空间用于存储函数调用栈。虽然对于斐波那契数列这样的简单计算来说，内存消耗可能不会太大，但在处理大量数据时，可能会造成内存占用过高的问题。
//推荐使用迭代（循环）的方式实现

//int fbn(int sc)  //迭代方式实现,避免消耗性能 栈溢出等问题
//{
//    // 如果 sc 为 0，则直接返回 0，因为斐波那契数列的第 0 项为 0
//    if (sc == 0)
//    {
//        return 0;
//    }
//    // 如果 sc 为 1，则直接返回 1，因为斐波那契数列的第 1 项为 1
//    else if (sc == 1)
//    {
//        return 1;
//    }
//
//    // 初始化斐波那契数列的前两个数字
//    int a = 0; // 第 0 项
//    int b = 1; // 第 1 项
//    int c = 0; // 用于存储当前计算的斐波那契数列项
//
//    // 循环迭代计算斐波那契数列的第 sc 个位置上的数字
//    while (sc > 1)
//    {
//        // 计算当前项，即前两项的和
//        c = a + b;
//        // 更新前两项的值，用于下一次计算
//        a = b;
//        b = c;
//        // 将 sc 减 1，准备计算下一项
//        sc = sc - 1;
//    }
//    // 返回斐波那契数列的第 sc 个位置上的数字
//    return c;
//}
//
//int main()
//{
//    // 定义变量用于存储用户输入的位置
//    int sc = 0;
//    // 从用户输入中读取位置值
//    printf("Enter the position of Fibonacci number: ");
//    scanf("%d", &sc);
//    // 调用 fbn 函数计算斐波那契数列的值
//    int fn = fbn(sc);
//    // 输出计算结果
//    printf("\n%d", fn);
//    return 0;
//}
//思考路程：
//了解斐波那契数列的定义：斐波那契数列是一个数列，其中每个数字都是前两个数字之和。通常定义第0项为0，第1项为1。
//为了计算斐波那契数列的第 sc 个位置上的数字，可以使用循环迭代的方式。在循环中，我们需要初始化斐波那契数列的前两个数字（第0项和第1项），然后逐步计算后续的数字，直到计算到第 sc 个位置上的数字。
//由于斐波那契数列的第0项和第1项已知，所以在计算第0项和第1项时，我们可以直接返回对应的值。
//在代码中，添加了注释来解释每一步的操作，以提高代码的可读性和可维护性。


//递归栈溢出现象, 那就是递归的层次太深的情况下比如:
//void test(int x)
//{
//    if (x < 10000)  
//        test(x + 1);  //Stack overflow 栈溢出
//}
//int main()
//{
//    test(1);
//    return 0;
//}
//可以使用static把局部变量改成静态,等方式,但不一定能彻底解决.
//把栈区内容放到静态区,达到一个平衡的效果,可以举一反三


//====================递归经典题目
//1.汉诺塔问题
//2.青蛙跳台阶问题.









//递归和迭代都是解决问题的有效方式，它们各有适用的场景。让我们讨论一下它们的应用场景：
//递归的应用场景：
//问题具有递归结构：某个问题的解可以通过对其子问题的递归求解来得到，这种情况下递归通常是最自然的选择。比如，树的遍历、图的深度优先搜索等问题。
//问题规模可以不断缩小：递归通常用于解决可以被拆分为规模较小的子问题的问题。每次递归调用都将问题规模减小，直到达到基本情况。
//数学问题：一些数学问题具有递归性质，如斐波那契数列、阶乘等。递归可以直接模拟数学定义，使得代码更加简洁。
//算法设计：一些算法的设计使用递归可以更加自然和简洁，例如分治算法和回溯算法。
//迭代的应用场景：
//性能要求较高：迭代通常比递归更高效，因为它避免了函数调用的开销和可能的栈溢出问题。对于性能要求较高的场景，迭代通常是更好的选择。
//问题规模较大：当问题的规模较大时，递归可能会导致栈溢出或者内存消耗过高的问题，此时迭代通常更加可靠。
//可读性和维护性要求较高：有些情况下，迭代实现比递归更直观易懂，更容易理解和维护。对于需要长期维护或者团队合作的项目，迭代通常更受欢迎。
//循环结构明显：对于一些明显的循环结构，如遍历数组、链表等，使用迭代更加直观。
//综上所述，选择递归还是迭代取决于问题的性质、性能需求以及代码的可读性和维护性要求。在实际应用中，根据具体情况选择合适的方法来解决问题是最重要的。

//想到函数递归就要想如何把这个数据拆分为最小..然后再约定条件


//====================作业详解==================

//1.请问下面代码执行结果是什么？
//int main()
//{
//    int i = 0;
//    for (i = 0; i < 10; i++)
//        if (i = 5)
//            printf("%d ", i);
//        //else  else 语句会与最近的未匹配的 if 语句相匹配。不一定是要对齐 
//    return 0;
//}
//答：一直打印5   if 表达式中i=5 ，是赋值操作，这会将 i 的值设置为5，然后i++ 为6,再进入if(i=5) 把6改成了5 如此循环往复
//相等性判断操作符 ==

//2.switch  case default 位置是可以随意的,但是要再switch语句块下才行.
// case default下面有多条语句时需要用花括号{}否则只会执行随后的一条语句.
// case 后面表达式只能是整型常量表达式.  char也是属于整数家族,因为它对应的是ascii值
// case 语句的顺序通常不会直接影响执行效率。编译器会生成一个跳转表
//int main()
//{
//   int shuru = 0;
//   scanf("%d", &shuru);
//   switch (shuru)
//   {
//   default:
//   {
//       printf("hhehe");
//       break;
//   }     
//   case 2:
//   {
//       printf("2");
//       break;
//   }
//   case 1:
//   {
//       printf("1");
//       break;
//   }
//   }
//   return 0;
//}

//int swi(int a)  //如果case条件成立,执行过程中没有遇到break 会顺序向下执行,所以b结果是0
//{
//    int b;
//    switch(a)
//    {
//        case 3: b = 30;       
//        case 1: b = 20;        
//        case 2: b = 16;      
//        defaule: b = 0;        
//    }
//    return b;
//}
//int main()
//{
//    int a = 1;
//    printf("%d",swi (a));
//    return 0;
//}

//int main()
//{
//    int a = 3;
//    int b = 3;
//    switch (a % 2)
//    {
//    case 1:
//        switch (b)
//        {
//        case 1:printf("123");
//        case 2:printf("24525");
//        default:
//        {
//            printf("caca");
//            break;  //这个break作用域是switch(b)
//        }
//        }
//    case 2:printf("hehe"); //这里会执行.
//    }
//    return 0;
//}

//========从大到小输出 如5461  输出6541
//int main()
//{
//    //输入
//    int a = 0;
//    int b = 0;
//    int c = 0;
//    scanf("%d %d %d", &a, &b, &c);
//
//    //排大小  交换变量的值
//    //假设一个最大值  
//    //直接套用 实际数字 来展开思路.以免思维混乱 假设用户输了 3 5 7
//    int d = 0;
//    if (a < b)
//    {
//        d = a;  //这里多次使用变量交换 可以设计一个交换变量函数 ,减少代码量
//        a = b;
//        b = d;
//    }
//    if (a < c)
//    {
//        d = a;
//        a = c;
//        c = d;
//     }
//    if (b <  c)
//    {
//        d = b;
//        b = c;
//        c = d;
//    }
//
//    //输出
//    printf("%d %d %d", a, b, c);
//    return 0;
//}

//通过函数交换变量方式 输出由大到小的整数.
//void jiaohuan(int* x, int* y)
//{
//    int tmp = *x;
//    *x = *y;
//    *y = tmp;   
//}
//
//int main()
//{
//    //输入
//    int a = 0;
//    int b = 0;
//    int c = 0;
//    scanf("%d %d %d", &a, &b, &c);
//
//    //排大小  交换变量的值
//    //假设一个最大值  
//    //直接套用 实际数字 来展开思路.以免思维混乱 假设用户输了 3 5 7
//    int d = 0;
//    if (a < b) //因为只有a小于b的时候交换才有意义,a要存最大的值
//    {
//        jiaohuan(&a, &b);
//    }
//    if (a < c)
//    {
//        jiaohuan(&a, &c);
//    }
//    if (b < c)
//    {
//        jiaohuan(&b, &c);
//    }
//    //输出
//    printf("%d %d %d", a, b, c);
//    return 0;
//}
//上面的问题不是很熟练,需要多练习 ..


//============打印1~100之间所有3的倍数数字.  尝试多个方法
//int main()//方式1   通过取余方式,能够被3整除没有余数来判断.
//{
//    //输出1~100
//    int i = 0;
//    for (i = 1; i <= 100; i++)
//    {
//        // 3的倍数 也就是能整除3，取余%3 
//        if (i % 3 == 0)
//        {
//            printf("%d ", i);
//        }
//    }
//    return 0;
//}

//int main()//方式2   从3开始,每次循环增加3,这样每次循环都是3的倍数.
//{
//    //输出1~100
//    int i = 0;                  //i = 3 是初始化语句，只会在循环开始时执行一次。
//    //for (i = 3; i <= 100; i+3)//i+3 的确会计算出6，但这个值并没有被保存到 i 中，因为这只是一个表达式 
//     for (i = 3; i <= 100; i =i+ 3) //所以i+=3才对,要保持i的值才能够保证每次循环增加
//    {
//            printf("%d ", i);
//    }
//    return 0;
//}

//void digui(int x)  //方式3  递归
//{
//    if (x > 100)
//    {
//        return 0;  // 终止条件：超过100时结束递归
//    }
//    if (x % 3 == 0)
//    {
//        printf("%d ", x);  // 当能被3整除时输出数字
//    }
//    digui(x + 1);  // 递归调用，参数加一继续判断下一个数字
//}
//
//int main()
//{
//    digui(1);  // 调用递归函数，从1开始判断能被3整除的数字
//    return 0;
//}


//============最大公约数
//给两个数 20 40 求最大公约数  也可以用递归.尝试多个方法
//int main()  //方式1 自己逻辑,用了很多的除法运算,会导致效率变低.
//{
//    //获取两个数
//    int a = 0;
//    int b = 0;
//    scanf("%d %d", &a, &b);
//    //求最大公约数
//    int zuixiao = a < b ? a : b;
//    int n = 0;
//    int x = 0;
//    for (n = 1; n <= zuixiao; n++)
//        if (a % n == 0 && b % n==0)
//        {       
//            x = n;
//        }
//    printf("%d", x);
//    return 0;
//}

//int main()  //方式2 欧几里得算法(辗转相除法)
//{
//    //获取输入
//    int a = 0;
//    int b = 0;
//    scanf("%d %d", &a, &b);
//    //求最大公约数,欧几里得算法
//    int i = 0;
//    
//    while (i=a%b)// 取余为0 说明是整除结束循环,同时while 0表示假.停止循环  每次进行取余运算
//    { 
//        a = b;
//        b = i;
//    }
//    printf("%d",a);
//    return 0;
//}
// 
//int ojl(int a, int b)  //方式3 ,调用函数.
//{
//    while (b != 0)
//    {
//        int tem = a % b;
//        a = b;
//        b = tem;  
//    }
//    return a;
//}
//
//int main() 
//{
//    //获取输入
//    int a;
//    int b;
//    scanf("%d %d", &a, &b);
//    //调用欧几里得函数
//    int jieguo= ojl(a, b);
//    //输出
//    printf("%d", jieguo);
//    return 0;
//}
//在欧几里得算法中，我们并不需要确保哪个值大。算法的原理是通过不断取两个数的余数，然后将被除数和除数交换，直到余数为0为止。
//即使初始时a和b的大小关系不确定，算法也能够正确执行，因为在每一步迭代中，我们都是用较大的数去除以较小的数。如果a比b大，
//第一次迭代中a会成为新的除数，b会成为新的被除数；如果b比a大，第一次迭代中b会成为新的除数，a会成为新的被除数。这样，无论哪个数更大，
//都会在第一次迭代中让较大的数成为新的除数。
//所以，无论a和b的初始值是什么，欧几里得算法都能够正确地找到它们的最大公约数。


//============打印1000~2000闰年
//年份能够被4整除，但不能被100整除的年份是闰年
//年份能够被400整除的年份也是闰年

//int runnian(int i)
//{
//    if (i % 4 == 0 && i % 100 != 0 || i % 400 == 0)
//    {
//        return i;
//    }
//    else
//        return 0;
//    
//}
//int main()
//{
//    //打印1000~2000
//    int i = 0;
//    for (i = 1000; i <= 2000; i++)
//    {
//        //调用闰年函数
//       int jieguo= runnian(i);
//       if (jieguo != 0)
//       {
//           printf("%d ", jieguo);
//       }
//    }
//    return 0;
//}


//============打印100~200素数
//素数是指除了1和自身以外没有其他正因数的自然数。
//int sushu(int x)
//{
//    for (int i = 3; i < x; i++)
//    {
//        if (x % i == 0)
//            return 0;  //注意返回条件.
//    }
//    return x;
//
//}
//int main()
//{
//    //打印100~200
//    int i = 0;
//    for (i = 100; i <= 200; i++)
//    {
//        //素数函数
//       int jg= sushu(i);
//       if(jg!=0)
//           printf("%d ", jg);   
//    }
//    return 0;
//}

//============1~100有多少个9
//int main()
//{
//    //1~100
//    int a = 0;
//    int z = 0;
//    for (a = 1; a <= 100; a++)
//    {
//        if (a % 10 == 9 )  //取个位的9
//        {
//            z++;
//        }
//        if ((a / 10) % 10==9)//取十位的9
//        {
//            z++;
//        }
//    }
//    printf("%d ", z);
//    return 0;
//}

//============分数求和
//计算1/1-1/2+1/3-1/...100的值
//int main()
//{
//    //1~100
//    int i = 0;
//    double sum = 0;
//    int zf = 1;
//    for (i = 1; i <= 100; i++)
//    {
//        sum = sum + zf*(1.0 / i);
//        zf = -zf; //一次负 二次负负得正. 正负循环
//    }
//    printf("%lf", sum);//%lf双浮点
//    return 0;
//}


//============输出99乘法表.
//int main()   //嵌套循环
//{
//    //计算99乘法表 ， 
//    //1*1=1
//    //2*1=2 2*2=4  ...
//    //规律是乘数1~9  被乘1~9
//    int 乘数 = 0;
//    int 被乘数 = 0;
//    int 乘积 = 0;
//    for (乘数 = 1; 乘数 <= 9; 乘数++)  //大循环控制乘数1~9
//    {
//        for (被乘数 = 1; 被乘数 <= 乘数; 被乘数++)//小循环控制被乘数1~9
//        {
//            乘积 = 乘数 * 被乘数;
//            printf("%d*%d=%-2d\t", 乘数, 被乘数, 乘积);  //%2d打印两位整数.方便格式右对齐  %-2d 左对其    \t tab 水平制表符
//        }
//        printf("\n"); //每次小循环乘完换行。
//    }
//    return 0;
//} //递归的方法就是把乘法表想象成 一个矩阵,有行 有列.


//============求10个整数最大的值
//int main()  //三目
//{
//    //创建10个整数
//    int arr[10] = { 1,2,3,4,100,6,7,8,9,10 };
//    //判断大小
//    int i = 0;
//    int z = arr[0];
//    for (i = 0; i <10; i++)
//    {
//        z=z > arr[i] ? z : arr[i];   
//    }
//    printf("%d", z);
//    return 0;
//}
//int main()  //判断
//{
//    //创建10个整数
//    int arr[10] = { 1,2,3,4,100,6,7,8,9,10 };
//    //判断大小
//    int i = 0;
//    int z = arr[0];
//    for (i = 1; i < 10; i++)
//    {
//        if (arr[i] > z)
//        {
//            z = arr[i];
//        }
//    }
//    printf("%d", z);
//    return 0;
//}







#include <time.h>
#include <windows.h>
#include <stdlib.h>
#include <string.h>
//============猜数字游戏
//void game()
//{
//    //设定随机数范围1~100
//    int suiji = rand() % 100 + 1;
//    //清屏
//    system("cls");
//    //循环判断
//    while (1)
//    {
//        int sr = 0;
//        scanf("%d", &sr);
//        if (sr == suiji)
//        {
//            printf("恭喜你猜对了\n随机数:%d\n", suiji);
//            break;
//        }
//        else if (sr > suiji)
//        {
//            printf("你猜大了\n%d", suiji);
//        }
//        else
//            printf("猜小了\n");
//    }
//}
//int main()
//{
//    //初始化种子
//    srand((unsigned int)time(NULL));
//    //主循环
//    int kaiguan = 1;
//
//        do
//        {
//            //提示信息
//            printf("请选择：\n1.开始游戏\n2.退出游戏\n");
//            //获取输入
//            int input = 0;
//            scanf("%d", &input);
//            switch (input) {
//            case 1:
//                // 开始游戏
//                game();
//                break;
//            case 2:
//                // 退出游戏
//                kaiguan = 0;
//                break;
//            default:
//                // 输入错误
//                printf("输入错误\n");
//                break;
//            }
//        } while (kaiguan);
//    return 0;
//}
//调用 srand((unsigned int)time(NULL)); 并不会触发压栈操作。实际上，srand 函数并不会将参数压入栈中。
//相反，它将设置一个全局的随机数种子，以供后续调用 rand 函数时使用。
//因此，尽管在其他函数中并没有显式调用 srand 函数来设置随机数生成器的种子，
//但由于在 main 函数中调用了 srand((unsigned int)time(NULL));，所以在程序的任何地方都可以
//使用 rand 函数来生成随机数，而且这些随机数都是根据 main 函数中设置的种子来生成的。


//============二分查找,在一个有序数组...查找n
//int chazhao(int a,int arr[],int gs)
//{
//    //边界值设定
//    int zuo = 0;
//    int you = gs - 1;
//    while (zuo <= you)
//    {
//        int zhong = zuo + (you - zuo) / 2;
//        if (arr[zhong] == a)
//            return zhong;
//        else if (arr[zhong] < a)
//            zuo = zhong + 1; //这里只是更新索引这个数字,并不是更新对应的元素,所以不能zuo=arr[zhong]+1 这样就成了数组内容+1
//        else if (arr[zhong] > a)
//            you = zhong - 1; 
//    }
//    return -1;
//   
//}
//
//int main()
//{
//    //创建有序数组
//    int arr[] = { 1,3,5,7,9,10,13,15,18,21 };
//    //获取数组总元素个数
//    int geshu = 0;
//    geshu = sizeof(arr) / sizeof(arr[0]);
//    //获取要查找的值
//    int sr = 0;
//    scanf("%d", &sr);
//    //调用查找
//    int jg = 0;
//    jg= chazhao(sr,arr,geshu);
//    //输出结果
//    if(jg!= -1)
//      printf("下标是:%d",jg);
//    else
//      printf("找不到");
//    return 0;
//}

//能不用判断最好不用,能把判断写到循环外最好写到循环外,提高效率
//https://www.bilibili.com/video/BV1Vm4y1r7jY/?p=49&vd_source=f7ddcd601961a1fdf039e8aebf4558fa.


















//需要复习的算法
//斐波那契数列
//阶乘
//素数
//闰年

//在复习
//1.
//模拟用户登录场景, 只允许输入三次密码错误.密码正确则提示登录成功, 失败三次程序退出.
//int main()
//{
//    //登录界面
//    printf("欢迎来到xxx系统,你有三次输入密码的机会\n");
//    //初始化密码
//    //abcde123
//    int i = 3;
//    for (i = 3; i > 0; i--)
//    {
//        //获取用户输入
//        char arr[20] = { 0 };
//        scanf("%s", &arr);
//        //判断密码
//        if (strcmp(arr, "abcd123")==0)//注意表达式strcmp字符串比较 ==0表示相等 >0正数 <0负数
//        {
//            printf("登录成功\n");
//            break; 
//        }
//        else
//        {
//            printf("密码输入错误,还有%d次机会\n",i-1); //不会影响变量 i 的值。在这个 printf 语句中，i-1 只是一个表达式
//        }
//    }
//    printf("程序退出\n");
//    return 0;
//}






//2.
//使用函数设计一个小游戏，随机产生1~100整数。
//根据用户选择，提示猜大了，猜小了。
#include <windows.h>
#include <stdlib.h>
#include <time.h>
//void 开始游戏()
//{
//    //设置随机值
//    int 随机值 = rand()%100+1; //记得取范围. 默认是0~32767
//    printf("恭喜你猜对了%d\n", 随机值);
//    int s = 0;
//    //system("cls");
//    while (1)
//    { 
//        printf("请猜测数值");
//        scanf("%d", &s);
//        if (随机值 == s)
//        {
//            printf("恭喜你猜对了%d\n", 随机值);
//            break;
//        }
//        else if (随机值 < s)
//        {
//            printf("大了\n");
//        }
//        else if (随机值 > s)
//        {
//            printf("小了了\n");
//        }
//    }
//}
//
//int main()
//{
//    int 开关 = 1;
//    //初始化种子
//    srand((unsigned int)time(NULL));
//    do
//    {
//    //提示信息
//    printf("***************************\n");
//    printf("***************************\n");
//    printf("********1开始游戏**********\n");
//    printf("********2退出游戏**********\n");
//    printf("***************************\n");
//    printf("***************************\n");
//
//    //游戏菜单
//    int xuanze = 0;
//    scanf("%d", &xuanze);
//    switch (xuanze)
//    {
//       
//    case 1:
//    {
//        开始游戏();
//        break;
//    }
//    case 2:
//    {
//        开关 = 0;
//        break;
//    }
//    default:
//        printf("输入错误\n");
//       
//    }
//
//    //设置随机数
//    //获取用户输入
//    //判断大小
//  
//    } while (开关);
//    return 0;
//}


//3.
//演示多个字符从两端移动,向中间汇聚.
//huanying guanglin!!!
//####################
//4.
//在一个无序数组中，查找某个数字。
//5.
//在有序数组查找某个数字,二分查找
//6.
//猜大小
//7.
//goto语句
//8.
//自动关机
//9.
//写一个函数可以找出两个整数中的最大值
//10.
//写一个函数可以交换两个整形变量的内容
//11.复习打印100~200之间的素数
//12.输出1000~2000闰年
//13.使用二分查找函数
//14.写一个函数每次调用num+1
//15.接受一个整数值(无符号),按照顺序打印它的每一位.  递归函数
//16.不使用临时变量,计算字符串长度 递归函数
//17.练习求N的阶乘  ，递归 与 迭代
//18.求第n个斐波那契数  递归 与 迭代


//=====================新知识点
//strcpy
//类型： 函数
//英文全拼： strcpy(String Copy)
//中文： 字符串拷贝
//头文件： <string.h>
//功能： 将一个字符串复制到另一个字符串中
// 
//memset 是 C 语言中的一个函数，用于将一块内存区域的内容设置为特定的值。
//英文全称: Memory Set
//中文意思 : 内存设置
//头文件 : #include <string.h>
//简短功能 : 将一段内存区域的内容设置为指定的值。

//名称：sqrt
//类型：函数
//英文全拼：Square Root
//中文：平方根
//头文件：math.h(数学库函数)
//功能：计算给定数的平方根。

//名称：bool       C99标准引入的  类型大小1字节 在特定的场景下使用可以节省空间
//类型：基本数据类型
//英文全拼：Boolean
//中文：布尔
//头文件：#include <stdbool.h>
//功能：布尔类型用于表示逻辑值，只有两个可能取值：true（真）和false（假）。

//#pragma comment 是 Visual C++ 特有的一个预处理器指令，用于向编译器发出特定的链接命令。它通常用于告诉编译器将某个库文件链接到正在编译的程序中。
//#pragma comment(lib, "library_name")

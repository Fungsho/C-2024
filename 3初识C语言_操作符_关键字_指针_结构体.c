#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>



//=======================================================操作符=============================================================================================
//	C 语言中有多种类型的操作符，它们用于执行不同的操作。以下是一些常见的 C 语言操作符：
//
//	算术操作符：用于执行基本的算术运算，如加法、减法、乘法、除法和取余等。例如： + 、 - 、 * 、 / 、 % 。
//
//	关系操作符：用于比较两个值的大小关系，返回布尔值（真或假）。例如： > 、<、 >= 、 <= 、 == 、 != 。
// 
//  单目操作符:	//++：递增操作符，用于将变量的值增加1。
				//--：递减操作符，用于将变量的值减少1。
				//& ：取地址操作符，用于获取变量的内存地址。
				//* ：解引用操作符，用于访问指针所指向的变量的值。
				// +：正号操作符，用于表示数值为正。
				// -：负号操作符，用于表示数值为负。
				// !：逻辑非操作符，用于对布尔值进行取反操作。
				// ~：按位取反操作符，用于对二进制数的每一位进行取反操作。
				// sizeof：用于获取数据类型或变量在内存中所占的字节数。
				// (type)：类型转换操作符，用于将一个表达式或变量转换为指定的数据类型。
//
//	逻辑操作符：用于执行逻辑运算，返回布尔值。例如： && （逻辑与）、 || （逻辑或）、!（逻辑非）。
//
//	赋值操作符：用于给变量赋值。例如： = 、 += 、 -= 、 *= 、 /= 等。
//
//	位操作符：用于对变量的二进制位进行操作。例如： & （按位与）、 | （按位或）、 ^ （按位异或）、 << （左移）、 >> （右移）等。
//
//	条件操作符（三元操作符）：用于根据条件选择两个值中的一个。语法为 条件 ? 表达式1 : 表达式2。
//
//	逗号操作符：用于在表达式中连接多个子表达式，按顺序执行，返回最后一个子表达式的值。语法为 表达式1, 表达式2。
//
//	成员选择操作符：用于访问结构体或联合体的成员。语法为 结构体变量.成员 或 指针->成员。
//
//	指针操作符：用于对指针进行操作。包括取地址操作符 & 、取值操作符 * 等。
//
//	这些是 C 语言中常见的操作符，它们允许你执行各种不同类型的操作，从而实现复杂的计算和逻辑。
// 要熟悉单目，双目，三目操作符的区别在于它们有几个操作数


//算术运算符：
//int main()
//{
//	int a = 7 / 2;//除号两端都是整数的时候执行的是整数除法.如果两端只要有一个浮点数那执行的就是浮点数除法
//	float t = 7 / 3.3;  //注意如果想实现小数注意数据类型,应为float
//	int b = 7 % 2; //取余，取摩
//	printf("%d\n%d\n", a, b);//%d 是用于格式化输出整数的占位符 其范围取决于所使用的数据类型对于 int 类型，通常是 32 位，范围约为 -2147483648 到 2147483647。
//	printf("%f\n", t);	//注意格式控制符号,输出%f 浮点类型
//	printf("%.2f\n", t);// .2表示展示小数点前两位.
//	return 0;
//}

//位运算符  位操作符：涉及到2进制运算,后期在学


//赋值操作符：用于给变量赋值。例如： = 、 += 、 -= 、 *= 、 /= 等。
//int main()
//{
//	等号= :赋值的意思
//	int a = 0;//创建变量A 同时给值 这叫初始化
//	a = 20;//赋值 当已有a这个变量,给它一个新的值就叫 赋值
//	a = a + 20;//a等于40 可简化
//	a += 20; //如同 a = a+20
//	a -= 3;//如同 a = a-3
//
//	return 0;
//}

//单目操作符是一种只接受一个操作数的操作符。在 C 语言中，常见的单目操作符包括：
//正负号操作符： + 和 - ，用于表示正数和负数。例如： + 5、 - 10。
//递增和递减操作符：++ 和 --，分别用于增加和减少变量的值。例如：x++、y--。
//取地址操作符： & ，用于获取变量的地址。例如： & a。
//取值操作符： * ，用于获取指针指向的值。例如： * ptr。
//逻辑非操作符：!，用于取反。例如：!flag。
//按位取反操作符：~，用于按位取反。例如：~mask。
//sizeof 操作符：sizeof，用于获取数据类型或变量的大小。例如：sizeof(int)、sizeof(a)。
//强制类型转换操作符：(type)，用于执行强制类型转换。例如：(float)x。
//这些单目操作符在 C 语言中用于执行各种操作，可以对变量进行增减、取反、获取地址等操作。


//a + b; //+左右都有操作数,这个加号+叫做双目操作符
//单目操作符,只有一个操作数的操作符.
//C语言如何规定真假 ,0表示假 非0表示真(-5例如也是真)
//int main()
//{
	//int zhenjia = 0;
	////逻辑反操作! ============
	//if (!zhenjia)  //单目操作符 !逻辑反操作就是真变假 ,假变真
	//{
	//	printf("%d\n",zhenjia);
	//	printf("假变真执行\n");
	//}

	////负值 - ================== 用于取一个数的负值。如果操作数是一个正数，则负号操作符 - 将其变为负数；
	//int a = -10;
	//int b = -a;//b等于负负10.
	//printf("%d\n", b);//负负得正 结果为10

	////正值 + ================正号操作符 + 主要用于强调一个数是正数，如果是负数就把它变成正数
	//int c = +a;
	//printf("%d\n", c);

	////sizeof ==============计算数据类型或变量所占用的字节数	是操作符,单目操作符,单位字节.
	//int s = 10;
	//printf("%d\n", sizeof(s));//可以输出s对应的变量,因为s变量类型是int  =4
	//printf("%d\n", sizeof(int));//也可以输出它的数据类型int   =4
	//printf("%d\n", sizeof s);//也可以省略括号,因为sizeof不是函数,是一个操作符
	////printf("%d\n", sizeof int);//这样写法是不支持的,对于类型数据要加括号() 因为 sizeof 后面需要跟着一个数据类型或者一个表达式。
	////如果是函数,一定要有()括号,不能省略. 总的来说，圆括号在 C 语言中用于改变表达式的优先级、提高代码的可读性、明确函数调用和定义复杂类型。
	//int arr[10] = { 1,2,3,4,5 };
	//printf("%d\n",sizeof (arr));// =44 因为有11个int ,一个int 4字节.
	//printf("%d\n", sizeof (arr[2]));//=4 这里要注意,它取的是数组中下标第三个元素,这个元素是int类型,sizeof获取的是这个数组中第三个位置元素的类型int ,所以是4
	//printf("%d\n", sizeof(arr) / sizeof(arr[1]));//10  数组的元素个数.  总数组大小除以1个数组元素大小就是元素个数.
	////由于数组 arr 的长度是 10，而每个元素的大小都相同，因此打印出的结果是 10，即数组 arr 中元素的个数。

	//前置\后置++  ================
	//int a = 10;
	//int b = a++; //后置++计算规则,先使用a的值,后++  意思是 b=a; a=a+1
	//int b = ++a; //前置++计算规则,先++ ,后使用	  意思是a=a+1; b=a
	//printf("%d\n", b); 
	//printf("%d\n", a);

	//前置\后置--   ===============
	//int a = 10;
	//int b = a--; //后置--计算规则,先使用a的值,后--  意思是 b=a; a=a-1
	//int b = --a; //前置--计算规则,先-- ,后使用	  意思是a=a-1; b=a
	//printf("%d\n", b);
	//printf("%d\n", a);

	//(类型)强制转换类型  强制类型转换操作符 (类型) 通常放在要转换的值的前面。
//	int b = 31.5;//字面浮点数,编译器默认理解为double类型
//	int a = (int)31.5;//意思强制把浮点31.5转换成整数舍弃后面的小数点(不会四舍五入).
//	printf("%d\n", a); //31
//	return 0;
//}

//================关系操作符
//// 大于:< 小于:> 大于等于>= 小于等于<= 等于== 不等于!=
//int main()
//{
//	int a = 10;
//	if (a = 2) //因为 一个= 是赋值,a=10 被重新赋值 a=2,条件成立. 由于括号,会优先表达()中的a=2所以成立.
//	{
//		printf("哈哈哈哈\n");
//	}
//	if (a == 2)
//	{
//		printf("两个等号,是判断相等,而不是赋值,需要区分清楚\n");
//	}
//	return 0;
//}
//================逻辑操作符
//逻辑与：&&
//示例：a&& b，表示当 a 和 b 都为真时，表达式为真。
//逻辑或：||
//示例：a || b，表示当 a 或 b 中有一个为真时，表达式为真。
//逻辑非：!
//示例：!a，表示当 a 为假时，表达式为真；当 a 为真时，表达式为假。
//int main()
//{
//	//逻辑与&& -- 并且的意思--相当于and 但在C语言不支持and操作符
//	int a = 10;
//	int b = 20;
//	if(a == 10 && b == 20)//&&逻辑与操作符 a相等于10并且b相等于20 条件成立.
//	{
//		printf("a相等于10并且b相等于20\n");
//	}
//	//逻辑或|| -- 或者的意思--相当于or  但在C语言不支持or 操作符
//	if (a || b)//||逻辑或操作符 a非0或者b非0 满足一个条件即成立.
//	{
//		printf("a或者b非0就是真\n");
//	}
//	//逻辑非!  -- 非 取反的意思
//	if (!a || !b)//判断,a为假,并且b为假.则成立 !非操作符,将本来为真的ab进行了取反操作.所以不成立
//	{
//		printf("aaaa\n");
//	}
//	return 0;
//}
// 
//================条件操作符(三目(三元)操作符,有三个操作数)
//condition ? value1 : value2 用于根据条件选择两个不同的值。
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int xiangdeng = 5;
//	int fouze = 6;
//	//求ab较大值  表达式1 (a>b) ? 表达式2 a  : 表达式3 b
//	int z = (b > a) ? xiangdeng : fouze;  //(a>b)是一个条件表达式，如果它的值为真（非零），则整个表达式的值为a，否则为 b。 如同if  else
//	//条件操作符的语法是(condition) ? value1 : value2。在这个语法中：
//	//condition 是一个条件表达式，如果它的值为真（非零），则整个条件表达式的值为 value1；否则为 value2。
//	//条件操作符和 if - else 结构可以互相替代，并且在某些情况下，条件操作符可以使代码更加简洁和清晰。
//	printf("%d\n", z);
//	return 0;
//}

//在条件操作符(condition) ? value1 : value2 中，圆括号是用来界定条件表达式的，因此在(b > a) 这样的条件表达式中加上额外的圆括号是没有必要的，也不会改变表达式的含义。
//所以，以下两种写法是等价的：
//int z = (b > a) ? y : x;
//int z = ((b > a) ? y : x);
//但从代码的可读性角度来看，不建议在(b > a) 这样的简单条件表达式中添加额外的圆括号，因为这会使代码显得冗余和不必要。

//================逗号表达式
// expr1, expr2, expr3, ..., exprN,
//由逗号隔开的一串表达式就是逗号表达式.
//逗号表达式特点:从左向右依次计算,整个表达式的结果是最后一个表达式的结果
//int main()
//{
//	int a = 11;
//	int b = 12;
//	int c = 13;
//	int z = (a + 6, b = a, b + 13); //从左到右依次计算第一个表达式17,第二个表达式11,第三个表达式24 所以z=24
//	printf("%d\n", z);
//}


//================下标引用,函数调用和结构成员操作符
//[] --- 称为下标引用操作符 数组索引操作符
//int main()
//{
//	//变量的值是在程序运行时才会有的。在程序编写阶段，你只是声明了变量并为其分配了内存空间，但是变量的实际值并没有确定。
//	//只有当程序运行起来，并且执行到相应的代码时，变量才会被赋予具体的值。
//	//所以数组大小要用常量来指定大小才有意义.
//	int arr[10] = { 1,2,3,4,5,6,7,8,9 }; //这里的[]不是操作符,只是定义形式. 定义数组大小的时候最好用常量.
//	int t = 2;//访问元素的时候 这里的变量赋值给下标引用操作符是可以的.
//	arr[t]=2000;//[]就是下标引用操作符	arr和2就是[]的操作数.
//	printf("%d\n", arr[2]);
//	return 0;
//}


//================函数调用操作符
//在 C 语言中，确实是通过圆括号() 来调用函数，但并不是所有拥有圆括号的表达式都表示函数调用。
//例如，在条件语句中，圆括号用于将条件表达式分组，而不表示函数调用。在数学表达式中，圆括号也常用于优先级控制，而不表示函数调用。
//但是，如果在圆括号内有函数名，并且后跟适当的参数列表，则这表示对该函数的调用。
//所以，虽然圆括号经常用于函数调用，但只有当圆括号内包含函数名和参数列表时，它才表示函数调用。
//int qiuhe(x, y)
//{
//	return(x + y);
//}
//int main()
//{
//	int a = 3;
//	int b = 8;
//	int sum = qiuhe(a, b);//qiuhe()就是函数调用操作符,操作数qiuhe,a,b 都是(函数调用操作符)的操作数
//	printf("%d\n", sum);  //函数调用必须有圆括号操作符() 
//	return 0;
//}
//================常见关键字(关键字不是创造出来的,也不能自己创建)=================
// 变量的名字不能是关键字
// 变量的命名要	1.有意义,	2.变量的名字必须是字母数字下划线组成不能有特殊字符,不能数字开头. 不建议用中文名.
//auto：用于声明自动变量，已经不常用了。
//break：用于跳出循环或 switch 语句。
//case：用于 switch 语句中的分支。
//char：用于声明字符型变量或字符型数据类型。
//const：用于声明只读变量。
//continue：用于跳过循环中的当前迭代。
//default：在 switch 语句中用于默认分支。
//do：引导 do - while 循环。
//double：用于声明双精度浮点型变量。
//else：用于 if 语句中的否定分支。
//enum：用于定义枚举类型。
//extern：用于声明外部变量或函数。
//float：用于声明单精度浮点型变量。
//for：引导 for 循环。
//goto：用于无条件跳转到代码中的标记位置。
//if：用于条件语句。

//register：用于声明寄存器变量，已经不常用了。
//return：用于从函数中返回值。
//int：用于声明整型变量。
//long：用于声明长整型变量。
//short：用于声明短整型变量。
//signed：用于声明带符号整型变量。
//sizeof：用于获取变量或类型的大小。
//static：用于声明静态变量或函数。
//struct：用于定义结构体。
//switch：用于多分支选择语句。
//typedef：用于给数据类型取别名。
//union：用于定义共用体。
//unsigned：用于声明无符号整型变量。
//void：用于声明无类型或表示无返回值的函数。
//volatile：用于声明易变变量，表示该变量的值可能会在程序执行期间被意外更改。
//while：引导 while 循环。
//int main()
//{
//	//通常所有局部变量都是auto类型,所以可以省略掉
//	auto int a = 99;//a变量是进入作用域自动创建,出了作用域自动销毁的.
//	return 0;
//}

 //================typedef类型定义
//typedef:中文意思类型定义 ,这里应该理解为类型重命名,可以把复杂的类型简化. 只能针对类型
//typedef unsigned int ui; //通过typedef关键字重命名unsigned int为ui
// 实际上，typedef 的主要作用是为现有的类型创建一个新的别名。这个别名可以是与原类型相同的名称，也可以是不同的名称。
//
////结构体示范,如何简化类型
// 定义一个结构体类型
//struct Person {
//	char name[20];
//	int age;
//};
//
//// 使用 typedef 定义结构体类型的别名
//typedef struct Person Person;//typedef 的主要作用是为现有的类型创建一个新的别名。这个别名可以是与原类型相同的名称
//
//int main() {
//	// 使用 Person 类型别名定义一个变量
//	Person person1 = { "Alice", 25 };
//
//	// 打印变量的值
//	printf("Name: %s, Age: %d\n", person1.name, person1.age);
//
//	return 0;
//}




//================static静态
//语法特点,会把修饰的变量放到静态区内存. 提前加载, 所以运行时候不执行相关区域的代码???这里存疑
//static是用来修饰变量和函数的
//1修饰局部变量-称为静态局部变量
//2修饰全局变量-称为静态全局变量
//3修饰函数-称为静态函数


//======================static修饰局部变量-称为静态局部变量  
//静态局部变量的生命周期与程序的执行时间相同，它们在程序启动时被创建，在程序结束时被销毁。
//void test()//void(空\无的意思)空类型或无类型 不返回任何值
//{
//	int a = 1;
//	static int b = 1; //static改变了修改局部变量时,局部变量出了作用域也不销毁,本质上static改变了变量的存储位置.
//	//这里需要结合内存相关的只是进行理解.
//	//内存分为多个区域
//	//栈区		局部变量  ----每次销毁
//	//堆区
//	//静态区	静态变量  ----不销毁, static把变量b变为了局部静态变量,此时变量b,在内存中位置分配到了静态区.
//										  //所以影响了变量的生命周期,声明周期变成了,和程序的生命周期一样长
//	//问:b变量成为局部静态变量后，是否和全局变量一样?
//	//作用域：局部静态变量的作用域仅限于声明它们的函数内部，而全局变量的作用域是整个文件范围内。因此，局部静态变量不能被其他函数访问，也不能被其他文件中的代码访问，而全局变量可以。
//	//初始化：局部静态变量和全局变量一样，只会在程序运行的第一次执行到定义它的代码行时进行初始化。之后的调用不会再次初始化它，而是保留上一次执行结束时的值，并在此基础上进行操作。
//	//持久性：局部静态变量和全局变量一样，它们的值在函数调用之间保持不变。每次函数调用时，局部静态变量的值会保留上一次函数调用结束时的值，并在此基础上进行操作。
//	//存储位置：局部静态变量和全局变量一样，它们的存储位置通常是在程序的静态存储区，也称为全局数据区。
//
//
//	//因为变量 b 是一个静态变量，它的生命周期跟程序的整个执行过程相关联，而不是跟函数的执行过程。
//	//在 C 语言中，静态变量的初始化只会在程序运行的第一次执行到定义它的代码行时进行，
//	//之后的调用不会再次初始化它，而是保留上一次执行结束时的值，并在此基础上进行操作。
//	b++;
//	printf("%d\n", b);
//	//这个过程可以通过F10调试,到了test()函数位置,按F11进入该函数区域,转到反汇编,可以看到static int b=1这里是没有反汇编语言的.没有参与执行
//	//问:静态变量初始化是在程序运行开始就提前加载到内存中了吗???
//	//是的，静态变量的初始化是在程序运行开始时就提前加载到内存中的。在程序启动时，静态变量的内存空间就会被分配，并且根据其初始化值进行初始化。
//	//这种提前加载到内存中的过程确保了静态变量在整个程序执行期间都是可用的，并且可以在程序的任何地方进行访问和修改。
//	//问:如果是在函数内的局部变量呢????
//	//自动局部变量：通常情况下，自动局部变量的内存空间在函数被调用时才会动态分配，而不是在程序运行开始时就提前加载到内存中。
//	//自动局部变量的初始化发生在函数被调用时，如果它有初始化语句的话。如果没有初始化语句，那么自动局部变量的值将是不确定的（即未初始化的状态）。
//	//静态局部变量：静态局部变量的初始化时机与静态全局变量类似，在程序运行开始时就会提前加载到内存中，并且根据其初始化值进行初始化。
//	//不同的是，静态局部变量的作用域仅限于声明它们的函数内部。
//	//和全局变量类似.
//}
//int main()
//{
//	int i = 0;
//	//当i小于10成立则循环运行while{}中的代码直到条件不成立,也就是i>10
//	while (i < 10)//; 错误提醒循环的末尾有一个分号，导致循环体为空.分号 ; 用于表示语句的结束。它会将之前的代码视为一个完整的语句
//	{
//		test();
//		i++;
//	}
//	return 0;
//	//问,为什么test的变量a每次都销毁,而main中的i变量为什么没销毁呢????
//	//答:main() 函数中声明的 i 也是局部变量，但由于它是在 main() 函数的代码块内部声明的，
//	//因此只要 main() 函数还在执行，i 的生命周期就会持续。在 main() 函数执行完毕后，i 也会被销毁。
//}
// 
//======================static修饰全局变量-称为静态全局变量  
//全局变量 在函数之外的大括号外部定义的变量，则被认为是全局变量。
//全局变量特点是具有外部链接属性的
//一个文件 要经过 编译+++链接>>>生成可执行程序
//extern int abc; //extern外部的意思 声明外部源文件符号
////static修饰全局变量的时候,这个全局变量的外部链接属性就变成了内部链接属性
////其他源文件(qwe.c)就不能在使用这个全局变了.
////改变变量的作用域可以保证安全性,和避免名字冲突.
//static int aaa;
//int main()
//{
//	printf("%d\n", abc);
//	return 0;
//}
////======================static修饰静态函数 
////函数也是具有外部链接属性的.如果被static修饰后,就变成内部静态函数了.
//extern int Add(int x, int y);//C语言编译器会从上到下逐行运行,如果ADD函数在外部文件没有声明的话,
//							 //会导致编译不认识这个函数,所以最好在main前面声明,或者写函数,减少报错与警告.
//static int Cdd(int x, int y) //static把一个具有外部链接的函数修饰成了静态函数,变成了内部链接属性了,其他(aa.c)源文件就无法引用了.
//{
//	return (x + y);
//}
//int main()
//{
//	int a = 10;
//	int b = 22;
//	int z = Cdd(a, b);
//	printf("%d\n", z);
//	return 0;
//}
//"static" 中文含义静态的  关键字可以用于控制变量和函数的作用域和存储方式，使得程序更加安全、可靠和高效。

//===============================register寄存器的意思
//电脑上有哪些储存设备(硬件)
//寄存器(集成CPU中)  ---空间小,速度快,造价高
//高速缓存(cache)
//内存
//硬盘				 ---空间大,速度慢,造价低
//int main()
//{
//	//大量重复使用的变量可以使用register寄存器变量.提升读取效率
//	register int num = 88; //建议把变量num放到寄存器中,并不是一定会放进去,取决于编译器的决定.
//	return 0;
//}

//===============================#define(定义\规定的意思)定义常量和宏
//#define 定义标识符常量
#define NUM 100//定义一个标识符NUM 等于100 的常量
//int main()
//{
//	printf("%d\n", NUM);//可以打印它的值
//	int a=NUM;//可以赋值
//	printf("%d\n", a);
//	int arr[NUM] = { 0 };//可以是数组索引,因为NUM是常量
//	return 0;
//}
//#define 定义宏  预处理指令
//				  预处理指令是一种特殊的命令，用于在编译源代码之前进行预处理操作。
//				  预处理指令以 # 符号开头，并在编译器对源代码进行编译之前由预处理器处理。
//宏是有参数的,跟函数类似但不同.  宏是替换的, 而函数是传参  宏适用于简单的代码替换和代码生成，
//而函数适用于封装一组语句并提供更复杂的逻辑和功能。在选择使用宏还是函数时，应根据具体情况和需求进行权衡。
// 
//#define ADD(x,y)((x)+(y)) //定义一个宏,宏名字ADD,宏参数(参数是无类型的就是个符号)(x,y),宏体((x)+(y))   要带括号更标准,也可以省略
//int main()
//{
//	int a = 12;
//	int b = 13;
//	int c = ADD(a,b); //宏是完成替换的, 而函数是传参. 所以调用ADD会替换成 int c = ((a)+(b));
//	printf("%d\n", c);
//	return 0;
// 宏定义的参数替换是简单的文本替换，没有类型检查或语法检查
// 宏可以接受任意数量的参数，并且参数的类型可以是任意的。
// 宏在展开时没有函数调用的开销，但可能会导致代码膨胀  :开销指的是在程序执行过程中产生的各种额外消耗，包括时间开销和资源开销。
//}


////C语言是结构化的程序设计语言--面向过程的语言
// 总的来说，面向过程编程注重任务的顺序和流程控制，而面向对象编程注重数据的封装和对象的行为。面向对象编程更加灵活、可扩展，可以更好地应对大型和复杂的软件系统开发。
////顺序结构
////选择结构
////循环结构
//
////要深刻了解
////	语法
////	转义字符
////    函数
////	库函数
////	标识符,标志符
////	格式控制符
////	ASCII编码
////	表达式
////	语法
////	操作符
////	关键字
////	分支语句
////	类型

//理解 C 语言中的各种括号和标点符号的使用确实很重要，因为它们可以改变表达式的含义和优先级。让我简单地解释一下它们的用法：
//
//圆括号()：
//用于将表达式分组，明确表达式的计算顺序。
//用于函数调用，将参数传递给函数。
//用于控制结构，如 if、for、while 等。
//方括号[]：
//用于数组的索引操作，表示访问数组中的元素。
//大括号{}：
//用于定义代码块，将多条语句组织在一起，例如在函数体、循环体和条件语句体中。
//用于初始化数组和结构体。
//逗号, ：
//用于分隔多个表达式或变量，在函数调用、变量声明、逗号表达式中等。
//分号; ：
//用于结束语句，在 C 语言中每条语句都以分号结尾。
//冒号 : ：
//用于标记标签，例如在 switch 语句中的 case 标签和 default 标签。
//用于指定成员访问运算符.和成员指针访问运算符->的左侧，表示结构体或联合体的成员名称。
//双引号 ""：
//用于表示字符串字面量。
//单引号 ''：
//用于表示字符字面量。
//点号.：
//用于访问结构体的成员。
//箭头->：
//用于访问结构体指针的成员。
//这些符号的使用是 C 语言中的基础，熟练掌握它们的用法可以帮助你编写清晰、正确的代码。


//.h头文件（函数的声明、类型的声明、头文件的包含）
//.c源文件（函数实现）
//浮点数有可能在内存中无法精确保存。不能用肉眼所见的值来计算


//=================================================指针================================================================

//=================================内存
//当电脑开机后，系统会对内存进行初始化，并为每个内存单元分配一个唯一的地址。
//这些地址通常是连续的，并按照一定规律分配。每个内存单元都有自己的地址，以便系统能够准确地定位和访问内存中的数据。
//内存是电脑上特别重要的存储器，计算机中程序的运行都在内存中进行的。
//所以为了有效的使用内存，就把内存划分成了一个个小的内存单元，每个内存单元的大小是1个字节(byte)。
//为了能够有效的访问到内存的每个单元，就给内存单元进行了编号，这些编号被称为该内存单元的地址。
	//内 存			地址
	//1字节			0XFFFFFFFF
	//1字节			0XFFFFFFFE
	//1字节			0XFFFFFFFD
	//1字节			0XFFFFFFFC
	//1字节			0XFFFFFFFB
//32位电脑 最多管理4GB内存。
//地址线
// 0/1
//32跟地址线: 2进制
//00000000 00000000 00000000 00000000
//00000000 00000000 00000000 00000001
//2的32次方个地址序列：
//字节=4294967296 byte
//KB=4194304 kb
//MB=4096mb
//GB=4gb
//64 位系统使用的是 64 位地址总线，最大能够寻址的内存空间为 2^64 个字节，即 16EB（1 EB = 1024 PB）
//int main()
//{
//	int (a) = 10;//向内存申请4个字节给变量a，储存整数10；
//	//32位二进制数	 0000 0000 0000 0000 0000 0000 0000 1010
//	//转16进制序列	 0x0000000a
//	//VS中查看内存监控内存序列是逆序的.要倒着看
//
//	&;	//取地址操作符
//		//0x000000000014FD14 是一个 64 位的地址，表示为 16 个十六进制数字，每个数字对应 4 个二进制位，总共有 64 位二进制位。
//		//0x010FF808 是一个 32 位的地址，表示为 8 个十六进制数字，每个数字对应 4 个二进制位，总共有 32 位二进制位。
//		//每个字节可以存储 8 位数据，所以 4 个字节可以存储 32 位数据(二进制bit)10，即一个整数。
// 		//每个字节可以存储 8 位数据，所以 8 个字节可以存储 64 位数据(二进制bit)01，即一个整数。
//		
//	printf("%p\n", &a);	//%p指针地址格式控制符;  变量a 每次程序结束就会销毁,所以每次运行地址都会发生变化
//						//32位打印是8个16进制;64位打印是16个16进制.
//	int	* p = &a;	//取变量a的地址,赋值给指针变量p . int 是因为 p指向的对象a 是int类型的所以指针变量p 是int类型
//					//在变量名前面加上*符号就是声明指针变量.
//					//为什么有个* ，它不是解引用符号吗，他们的不同是：
//					//声明指针变量时int	* p 声明有指向的类型
//					//使用指针变量时*p 表示获取 p 所指向的整数值。
//					//在声明指针变量时，它表示指针类型的声明；在使用指针变量时，它表示解引用操作符。
// 
//	//int*(p) = &a;	// 这样写也行.为了方便区分,变量可以加上括号,通常情况下声明变量时不需要加上圆括号
//					// 在使用强制类型转换时，需要使用圆括号将表达式括起来
//					// 在宏定义中，参数可能需要使用圆括号括起来	
//	//为什么叫指针变量???
//	//因为内存中每个单元都有地址(编号),这个地址也被称为指针.既内存地址就是指针
//	//指针是一个变量(指针是一种特殊类型的变量，它存储的值是另一个变量的内存地址。)，
//	//它存储了另一个变量的内存地址。换句话说，指针变量包含了一个
//	//内存地址，它指向内存中的某个位置。因此，当我们说"内存地址"时，我们指的就是指针所指向的位置。
//
//	char ch = 'w';
//	char* (pp) = &ch;	//不建议这样用括号,虽然可以正常运行,但是难以理解.
//	printf("%p\n",pp);	//解引用操作符，
//						//将指针 pp 指向了变量 ch 的地址，然后通过* pp 来修改变量 ch 的值
//						//意思就是通过指针变量pp的地址，找到pp所指向的对象，*pp就是p指向的对象
//
//	*pp = 'm';
//	printf("%c\n", ch);
//
//	//逆向思路, 通过&取地址操作符获取内存地址,再用 * 解引用操作符找回去并赋值.
//	//可以通过取地址操作符 & 获取变量的内存地址，然后使用解引用操作符 * 访问该内存地址并进行赋值操作。
//	return 0;
//}//解引用*操作符，读取值；可以获取指针指向的值,
//					赋值  ：也可以所指向的位置进行赋值

//=================================指针变量的大小
//指针变量大小取决于,地址的大小
//32位平台下地址是32个bit位(即4个字节)
//64位平台下地址是64个bit位(即8个字节)
//指针可以指向不同类型的数据，包括变量、数组、结构体等。在 C 语言中，
//指针的类型必须与其指向的数据类型相匹配，但是在某些情况下，类型之间存在隐式转换。
//int main()
//{
//	//int* p;
//	//char* p2;
//	//不管什么类型的指针,都是在创建指针变量.
//	//指针变量是用来存放地址的.
//	printf("%zu\n", sizeof(char*));//* 通常放在变量名的右侧，而在类型名后面表示指针类型
//	printf("%zu\n", sizeof(int*));//8 因为它的地址大小是8个字节
//	printf("%zu\n", sizeof(short*));//8 因为它的地址大小是8个字节
//	printf("%zu\n", sizeof(float*));//8 因为它的地址大小是8个字节
//	printf("%zu\n", sizeof(double*));//8 因为它的地址大小是8个字节
//	//	sizeof 是 C 语言中的一个单目运算符，用于获取操作数的字节长度。
//	//	double* 表示指向 double 型数据的指针。
//	//	printf 函数用于格式化输出数据。
//	//	% zu 是 printf 函数的格式化说明符，用于输出无符号整数。
//	return 0;
	//理解了一个困惑我的问题了.我一直搞不懂64位地址长度是16个16进制为什么是8个字节,
	//是我理解错了,要这样理解.
	//8个字节是用于存放地址的!!!!
	//由于64位地址包含64位二进制数，因此需要8个字节（每个字节存储8位）才能存储完整的地址值。
	//00 00 00 00 00 14 FD 14  每个十六进制数代表4位二进制数。所以00是(bit)一个字节.一共是8个字节的地址!!!
//} 

	//0x000000000014FD14地址是8个字节的原因：
	//	1. 地址长度与体系结构相关:
	//	计算机地址的长度取决于计算机的体系结构。在64位体系结构中，地址通常由8个字节组成，每个字节存储8位二进制数。这些二进制数组合在一起，形成一个唯一的地址值。
	//	2. 0x000000000014FD14 是64位地址 :
	//	根据十六进制表示法，0x000000000014FD14 可以分解为如下：
	//	00 00 00 00 00 14 FD 14
	//	每个十六进制数代表4位二进制数。将所有十六进制数转换为二进制数，并连接在一起，得到：
	//	0000000000000000000000001111110101011100
	//	这串二进制数的长度为64位，因此 0x000000000014FD14 是一个64位地址。
	//	3. 64位地址需要8个字节存储:
	//	由于64位地址包含64位二进制数，因此需要8个字节（每个字节存储8位）才能存储完整的地址值。
	//	总结 :
	//	0x000000000014FD14 是一个64位地址。
	//	64位地址需要8个字节存储，因为64位地址包含64位二进制数，而每个字节存储8位二进制数。
	//	以下是一些额外的解释：
	//	在32位体系结构中，地址通常由4个字节组成。
	//	一些编译器可能会对指针进行对齐操作，这可能会导致其长度略大于地址的实际长度。
	//	在一些情况下，地址可能只使用一部分字节，例如在虚拟内存中，地址的一部分用于标识页表项。
	// 关于*位置补充.
//int main()
//{
//	int* p;
//	int *pp;
//	int* q, w, e; //这样只会声明了一个指向整数的指针变量 q
//	int* y, *u, *i;//这样写才会声明y,u,i都是指针变量.
//	int* (j), * (k), * (l);	//可以加上圆括号来提高代码的可读性。 但不规范只是示范
//	int(*jf), (*kk), (*kl);//可以加上圆括号来提高代码的可读性。 但不规范只是示范
//	return 0;
//}

//======================================struct结构体==============================================================
//int,char,long,short,float,double,这些都是表示一些具体的对象,
//如果表达一个人,有名字,有年龄,有体温等这样复杂的信息
//C语言给了自定义类型的能力,自定义类型中有一种叫:
//结构体:struct
//结构体是C语言中特别重要的知识点,结构体使得C语言有能力描述复杂类型.
//比如描述学生,学生包含:名字,年龄,性别,学号,这几项信息.
//这里只能用结构体来描述了.
// 
//结构体是把一些单一类型组合在一起的做法.

//学生结构体
//struct Stu		//struct Stu就是一个自定义类型,可以用这个类型创建变量:struct Stu xxx1;（struct语法结构本身并没有参数）
//{
//	//成员----结构体成员变量声明
//	char name[20];
//	int age;
//	float tiwen;
//	char sex[10];
//	char tele[12];
//};	//这个类型不占用空间,它就像图纸一样,是盖房子的设计图,只有给这个自定义类型创建变量才会创建空间
//
//
////这里不好理解其实是这样的:
////struct Stu是个数据类型(自定义的)，告诉ps 的类型是struct Stu
////就比如 我告诉这个ps参数,你的类型是int , 那么就是 dayin(int ps)
////只不过这个自定义类型,类型名字是struct Stu
////*解引用是指通过指针访问其所指向的对象或变量的值。在C语言中，解引用操作使用 * 符号。
////由于main中的dayin函数,传递了一个参数&s,就是取变量s的内存地址.
////在自定义函数dayin 创建了一个ps变量来接收s内存地址, 因为s的数据类型是staruct Stu, 
////所以自定义函数的参数ps变量类型也要一样.
////通过*解引用操作符,通过指针访问其所指向的对象或变量的值。
//void dayin(struct Stu* ps)
//{								//这里要加括号,加括号的逻辑是,圆括号是优先级最高的,所以先找对象,在找成员
//	printf(" %s %d %.1f %s %s\n", (*ps).name, (*ps).age, (*ps).tiwen, (*ps).sex, (*ps).tele);
//	//  -> 左边是结构体指针变量,右边是成员名 
//	printf(" %s %d %.1f %s %s\n", ps->name, ps->age, ps->tiwen, ps->sex, ps->tele);
//}
//
//int main()
//{
//	struct Stu s = { "fengshuo",18,36.5,"nan","13366618843" };
//	//点 .操作符左边是结构体对象,右边是成员名
//	printf("姓名:%s\n年龄:%d\n体温:%.1f\n性别:%s\n电话:%s\n",s.name,s.age,s.tiwen,s.sex,s.tele);
//	dayin(&s);
//	return 0;
//}
//*解引用操作符,也叫间接访问操作符


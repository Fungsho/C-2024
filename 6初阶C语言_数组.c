#define _CRT_SECURE_NO_WARNINGS 1

//==========================数组==========================================
//1.一维数组的创建和初始化
//2.一维数组的使用
//3.一维数组在内存中的存储
//4.二维数组的创建和初始化
//5.二维数组的使用
//6.二维数组在内存中的存储
//7.数组越界
//8.数组作为函数参数
//9.数组的应用实例1:三子棋
//10.数组的应用实例2 : 扫雷游戏



//==========================1.一维数组的创建和初始化=======================
//数组的创建
//数组是一组相同类型元素的集合.

//一维数组语法:
//type_t arr_name[const_n];   //type_t 是指元素类型   //arr_name 数组名   //const_n 是一个常量表达式,用来指定数组的大小.

//int main() //数组创建实例
//{
//	//创建10个整型数字的数组
//	int arr[10]; //表示数组大小为10,有10个元素{0,1,2,3,4,5,6,7,8,9} ..需要注意不包含10
//	//创建一个字符数组.
//	char ch[5+5]; //常量表达式
//
//	int n = 10;
//	char arr2[n]; //只能在支持C99标准编译器上编译. 变长数组是不能初始化的.
//	//在C99标准之前,数组的大小必须是常量或者常量表达式.
//	//在C99之后,数组的大小可以是变量,为了支持变长的数组.
//	return 0;
//}

//数组的初始化.
//数组的初始化是指,在创建数组的同时给数组的内容一些合理的初始值(初始化).
//int main()
//{
//	//不完全初始化,剩余的元素默认初始化为0
//	int arr[10] = { 1,2,3 };
//	//完全初始化
//	int arr1[10] = { 0,1,2,3,4,5,6,7,8,9 };
//	//根据初始化内容,创建数组大小
//	int arrq[] = { 1,1,2,3,4,5,6 };
//	//1,1,2,3,4,5,6
//	char arr3[10] = { 'a','b','c' };  //三个元素,剩下的初始化为0
//	//a b c 0 0 0 0 0 0 0
//	char arr3[10] = "abc"; ///双引号方式不同的地方是未完全初始化会在字符串结尾添加\0  相当于给数组放入4个元素. 虽然这两种方式略有不同，但最终数组的内容确实是相同的，只是初始化方式不同而已。
//	//a b c \0 0 0 0 0 0 0
//	char arr4[] = { 'a','b','c' }; //数组大小3
//	char arr6[] = "abc"; //数组大小4 多了个\0
//	return 0;
//}

#include <stdio.h>

//=============================2.一维数组的使用=====================
//对于数组的使用我们之前介绍了一个操作符:[],下标引用操作符.它其实就是数组访问的操作符.
//int main()
//{
//	//这是一个局部数组,在内存中栈区找了一块连续空间放了这10个元素
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10 }; //c语言规定数组的下标是从0开始的.
//	//[]: 下标引用操作符
//	printf("%d\n", arr[4]);//对应的就是第四个元素内容是5
//	//打印数组内容
//	//计算数组大小
//	int szdx = sizeof(arr) / sizeof(arr[0]);//sizeof 获取数据类型或变量所占用的字节数  通过总大小除以元素个数,得到总个数.
//	//循环打印 从下标0开始 正序
//	int i = 0;
//	for (i = 0; i < szdx; i++) //这里i代表的是数组下标,因为下标是从0开始,对应的元素总个数要-1 ,所以不能是i<=szdx
//	{
//		printf("%d ", arr[i]);
//	}
//	//循环打印 从最大下标开始 倒叙
//	for (i = szdx - 1; i >= 0; i--)
//	{
//		printf("\n%d ", arr[i]);
//	}
//	return 0;
//}
//总结:1数组是使用下标来访问的,下标是从0开始.  2.数组的大小可以通过计算得到.

//==========================3.一维数组在内存中的存储======================================
//int main()
//{
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
//	int szdx = sizeof(arr) / sizeof(arr[0]);
//	int i = 0;
//	for (i = 0; i < szdx; i++) 
//	{
//		printf("&arr[%d] %p\n",i, &arr[i]);  //%p 打印地址  &arr打印数组地址.
//	}
//		//& arr[0] 000000000014FCB8		即使在64位系统中，内存地址仍然按照字节寻址。因此，两个相邻地址之间的间隔仍然是一个字节，即8位。
//		//& arr[1] 000000000014FCBC     int类型是4字节,所以每个地址间隔4字节
//		//& arr[2] 000000000014FCC0		每个字节在内存中都有一个唯一的地址。这些地址通常是连续的，并且从0开始递增，每个地址对应内存中的一个字节。
//		//& arr[3] 000000000014FCC4		地址从低地址到高地址变化.
//		//& arr[4] 000000000014FCC8
//		//& arr[5] 000000000014FCCC
//		//& arr[6] 000000000014FCD0
//		//& arr[7] 000000000014FCD4
//		//& arr[8] 000000000014FCD8
//		//& arr[9] 000000000014FCDC
//	return 0;
//}
//总结:随着下标的增长,元素的地址,也有规律的递增(低地址>高地址),因此数组在内存中是连续存放的.
//全局变量在某些情况下可能会提高运行效率，但并不总是如此。

//====================================4.二维数组的创建和初始化========================================
//=========================二维数组创建
//int arr[3][4];
//char arr1[3][4];
//double arr2[2][4];
//=========================二维数组初始化
//1 2 3 4
//2 3 4 5
//3 4 5 6 
//int arr[3][4] = {1,2,3,4,2,3,4,5,3,4,5,6}; //完全初始化,1234在第一组 以此类推 3行4列
//int arr[3][4] = {1,2,3,4};//不完全初始化,每组元素不满足4列自动补0
//int arr[3][4] = { {1,2},{2,3},{4,5} };//指定分组,12为第一组不足4列补零  23第二组....
//int arr[][] = { {1,2},{2,3},{4,5} };//错误写法,行可以省略,列不可以省略
//int arr[][4] = { {1,2},{2,3},{4,5} };//正确写法.
//char arr1[3][4];
//double arr2[2][4];


//二维数组就像表格一样,先确定行(0行开始),在确定列(0列开始),通过第几行第几列来确定具体某个元素;
////打印数组
//int main()
//{
//	//创建二维数组
//	int arr[3][4] = { 1,2,3,4,2,3,4,5,3,4,5,6 };
//	//嵌套循环定位行列
//	int i = 0;
//	for (i = 0; i < 3; i++)
//	{
//		int j = 0;
//		for (j = 0; j < 4; j++)
//		{
//		printf("%d ",arr[i][j]);
//		}
//		printf("\n");//因为打印完列 ,在换行打印第二行.所以不能写到上一个循环里.
//	}
//	return 0;
//}

//================================================5.二维数组的使用================================================================

//打印数组================
//int main()
//{
//	//创建二维数组
//	int arr[3][4] = { 1,2,3,4,2,3,4,5,3,4,5,6 };
//	//嵌套循环定位行列
//	int i = 0;
//	for (i = 0; i < 3; i++)
//	{
//		int j = 0;
//		for (j = 0; j < 4; j++)
//		{
//			//此处运行了12次每次向数组写入一个元素值.
//			scanf("%d", &arr[i][j]);//在C语言中，空格通常用来分隔不同的输入。但是，scanf函数会自动忽略掉你输入的整数前后的空格，这样就不需要你在%d后面加空格了。
//			/*当scanf函数遇到空格、制表符或换行符时，它会将其视为分隔符，表示当前输入结束，然后开始读取下一个输入
//			因此，无论你输入的是空格还是回车，scanf都会认为当前数字输入结束，然后准备读取下一个数字。*/
//		}
//		
//	}
	//for (i = 0; i < 3; i++)
	//{
	//	int j = 0;
	//	for (j = 0; j < 4; j++)
	//	{
	//		printf("%d ", arr[i][j]);
	//	}
	//	printf("\n");//因为打印完列 ,在换行打印第二行.所以不能写到上一个循环里.
	//}
//	return 0;
//}
//二维数组可以理解为:每一行是一个一维数组
//arr[0][j]; arr[0]看作是一行的数组名. j就是数组大小.因此
//arr[1][j]; arr[1]可以看作是一个数组名,j是数组大小 这样就跟一维数组一样了.
//arr[2][j];



//================================================6.二维数组在内存中的存储================================================
//arr[3][4] 内存布局与arr[12] 是相同的.只是访问形式不同.
//由低地址到高地址连续的一块空间,  arr[0] 接着 arr[1] 接着 arr[2]  三个连续的一维数组.
//声明一个二维数组时，第一维的大小可以省略，但第二维的大小必须指定。省略第二维的大小是不合法的，因为编译器无法确定第二维的大小。
//打印数组地址
//int main()
//{
//	int arr[3][4] = { 1,2,3,4,5,6,7,8,9,4,5,5 };
//	int i = 0;
//	for (i = 0; i < 3; i++)
//	{
//		int j = 0;
//		for (j = 0; j < 4; j++)
//		{
//			printf("&arr[%d][%d]=%p\n", i, j, &arr[i][j]);
//		}
//	}
//	return 0;
//}
//& arr[0][0] = 000000000014FCA8   //由低地址到高地址连续的一块空间,  arr[0] 接着 arr[1] 接着 arr[2]  三个连续的一维数组.
//& arr[0][1] = 000000000014FCAC   //arr[3][4] 内存布局与arr[12] 是相同的.只是访问形式不同.
//& arr[0][2] = 000000000014FCB0
//& arr[0][3] = 000000000014FCB4
//& arr[1][0] = 000000000014FCB8
//& arr[1][1] = 000000000014FCBC
//& arr[1][2] = 000000000014FCC0
//& arr[1][3] = 000000000014FCC4
//& arr[2][0] = 000000000014FCC8
//& arr[2][1] = 000000000014FCCC
//& arr[2][2] = 000000000014FCD0
//& arr[2][3] = 000000000014FCD4




//==========================================7.数组越界=============================================
//数组的下标是有范围限制的。
//数组的下标规定是从0开始的，如果数组有n个元素，最后一个元素的下标就是n - 1。
//所以数组的下标如果小于0，或者大于n - 1, 就是数组越界访问了，超出了数组合法空间的访问。
//C语言本身是不做数组下标的越界检查, 编译器也不一定报错, 但是编译器不报错, 并不意味着程序就是正确的,
//所以程序员写代码时，最好自己做越界的检查。
//int main()
//{
//	int arr[] = { 1,2,3,4,5,6 };
//	int sz = sizeof(arr) / sizeof(arr[0]); //等于24/4=6  最大下标=6-1  
//	int i = 0;
//	//通过i与sz变量的比较规定数组的界限
//	for (i = 0; i < sz; i++)
//	{
//		printf("%d", arr[i]);
//	}
//	return 0;
//}

//在绝大多数情况下， < 的执行效率会比 <= 高。这是因为在 < 的比较中，只有在左操作数小于右操作数时才返回真，
//而在 <= 的比较中，除了左操作数小于右操作数时返回真，还包括左操作数等于右操作数时也返回真。
//所以尽量多使用大于小于


//==========================8.数组作为函数参数=====================================
//往往我们在写代码的时候，会将数组作为参数传个函数，比如:我要实现个冒泡排序(这里要讲算法思想)函数
//将一个整形数组排序。

//数组传参的时候形参有两种写法:
//1.数组   -- 直观辨识度高.容易理解
//2.指针
//
//冒泡算法升序 
//void maopao(int arr[],int sc) //地址应该用指针来接收,arr[]看似是数组,本质是指针变量. 这里传的一定是首元素地址 而不是首元素.[10]可写可不写没意义
//{
//	//冒泡排序核心思想是比较两个相邻的值
//	//计算数组大小----------------这是错误的写法.
//	//int sz = sizeof(arr) / sizeof(arr[0]);//因为数组传参是传递的数组首元素地址. 这里相当于首地址/首地址.4/4=1
//	int i = 0;//作为数组下标和循环变量.
//	for (i = 0; i < sc-1; i++)//sc - 1 表示数组的最后一个元素的索引。因为数组的索引是从0开始的，所以数组的最后一个元素的索引是 sc - 1。
//	{
//		int j = 0;
//		for (j = 0; j<sc-1-i; j++) //这里通过j 来作为数组起始下标 sc-1 做大下标 i首次为0  就相当于 sc-1-0  第二次自增 sc-1-1  实现了每次少比较一次的效果. :优化的冒泡排序
//		{
//			 //需注意的是内层循环arr[]变量不要用外层的i,应该用内层j.
//			if (arr[j] > arr[j + 1])   //arr[0]<arr[1] ...arr[1] <arr[2] 每次循环比较j从下标0开始 比较j+1 每次j下标自增,同时比较j+1   
//			{
//				//通过临时变量将较大值交换
//				int tem = arr[j];
//				arr[j] = arr[j+ 1];
//				arr[j + 1] = tem;
//				//理解起来很简单 比如吧 a b两个交换下, 那就是a=b  b=a 但是直接交换会导致a原先的内容直接被b覆盖,所以要一个临时变量来存a
//			}
//		}
//
//	}
//
//} //算法这种函数一定要清楚的知道变量都代表是什么属性.. 一定要搞清楚 这些变量都是在为 数组下标进行变化,来实现的排序.
//    无非就是通过次数作为数组索引..
//
//int main()  //冒泡排序算法
//{
//	//创建无序数组
//	int arr[] = { 8,6,4,3,2,7,6,9,1,0 };
//	//计算数组大小
//	int sc = sizeof(arr) / sizeof(arr[0]);//由于数组传参是传递的一个数组首元素地址,所以需要提前计算得到并传参给函数
//	//调用冒泡算法
//	maopao(arr,sc);//arr 这个数组名本质上是:数组首元素地址
//	for (int i = 0; i < sc; i++)
//	{
//		printf("%d ",arr[i]);
//	}
//	return 0;
//}
//冒泡排序是一种简单直观的排序算法，理解它的原理并不难。以下是一个简单的步骤来帮助你快速学习并理解冒泡排序的原理：
//核心思想：冒泡排序的核心思想是通过比较相邻的两个元素，将较大（或较小）的元素交换到右边（或左边），从而逐步使得整个数组变得有序。
//具体步骤：
//从数组的第一个元素开始，依次比较相邻的两个元素。
//如果左边的元素比右边的元素大（或小），则交换这两个元素的位置。
//重复以上步骤，直到没有任何一对相邻的元素需要交换为止。
//这样，经过一轮的比较和交换，最大（或最小）的元素会“冒泡”到数组的最右端（或最左端）。
//接着，对除了最后一个（或第一个）元素以外的所有元素重复上述步骤，直到整个数组排序完成。
//示例：考虑一个简单的例子，初始数组为{ 5, 3, 8, 4, 2 }：
//第一轮比较：比较相邻的两个元素，交换 5 和 3，得到{ 3, 5, 8, 4, 2 }；然后再比较 5 和 8，无需交换；接着比较 8 和 4，交换得到{ 3, 5, 4, 8, 2 }；最后比较 8 和 2，交换得到{ 3, 5, 4, 2, 8 }。
//第二轮比较：重复上述步骤，得到{ 3, 4, 2, 5, 8 }。
//第三轮比较：继续重复上述步骤，得到{ 3, 2, 4, 5, 8 }。
//第四轮比较：最后一次比较后，数组已经有序，排序完成。
//通过以上步骤，你应该能够对冒泡排序的原理有一个基本的了解。如果你想进一步加深理解，可以尝试在纸上模拟每一步的比较和交换过程，或者编写简单的代码来实现冒泡排序。

//冒泡算法降序
//void maopao(int* arr, int sc) //形参arr是指针的形式
//{
//	//循环趟数下标0~最大下标=sc-1
//	int i = 0;
//	for (i = 0; i < sc-1; i++)
//	{
//		//每趟的排序
//		int j = 0;
//		for (j = 0; j < sc - 1 - i; j++)
//		{
//			//把较小的值与j+1交换
//			if (arr[j] < arr[j + 1])
//			{
//				int tem = arr[j];
//				arr[j] = arr[j + 1];
//				arr[j + 1] = tem;
//			}
//		}
//		//外层循环控制趟数，内层循环依次比较相邻元素并进行交换。
//		
//	}
//
//}
//
//int main()
//{
//	//创建数组
//	int arr[] = { 7,85,6,1,3,2,9,5 };
//	//计算数组大小
//	int sc = sizeof(arr) / sizeof(arr[0]);
//	//调用冒泡排序函数
//	maopao(arr, sc);
//	//输出
//	int i = 0;
//	for (i = 0; i < sc; i++)
//	{
//		printf("%d\n", arr[i]);
//	}
//	return 0;
//}











//===========================数组名是什么?==========================================
//数组名确实能表示首元素的地址
//但有2个例外:
//1. sizeof(数组名), 这里的数组名表示整个数组,计算整个数组的大小,单位是字节
//2. &数组名,这里的数组名表示整个数组,取出的是整个数组的地址
//int main()
//{
//	int arr[10] = { 0 };
//	printf("%p\n", arr);  //000000000014FCF8
//	printf("%p\n", arr+1);//000000000014FCFC
//	printf("-------------------------\n");
//	printf("%p\n", &arr[0]);  //000000000014FCF8
//	printf("%p\n", &arr[0]+1);//000000000014FCFC
//	printf("-------------------------\n");
//	printf("%p\n", &arr);	//000000000014FCF8     &arr+1 确实指向的是数组之后的一段内存，而且这段内存的大小与整个数组的大小是一样的。
//	printf("%p\n", &arr+1); //000000000014FD20    相差40  &arr+1 的值是 0x1000 + sizeof(arr)，即数组地址加上整个数组的大小。
//	//&arr 输出的是整个数组的地址，而& arr + 1 输出的是整个数组地址的下一个地址，这是因为数组在内存中是连续存储的，所以数组的下一个地址就是当前数组地址加上整个数组的大小。
//	int sz = sizeof(arr); 
//	printf("%d\n", sz);//40字节
//	return 0;
//}

//&arr[0 + 1] 和& arr[0] + 1 分别表示不同的地址。
//& arr[0 + 1]：表示数组中索引为1的元素的地址，即数组中第二个元素的地址。
//& arr[0] + 1：表示数组的地址加上1的值。由于数组名是数组的首地址，因此 & arr[0] 表示数组的地址，加上1表示数组地址的下一个地址。
//具体来说，假设有一个数组 arr，其首地址为 0x1000，且每个元素占据4个字节：
//& arr[0 + 1] 表示索引为1的元素的地址，即 0x1000 + 1 * 4 = 0x1004。
//& arr[0] + 1 表示数组的地址加上1的值，即 0x1000 + 1 = 0x1001。
//所以， & arr[0 + 1] 和 & arr[0] + 1 的结果是不同的。前者表示数组中第二个元素的地址，后者表示数组地址的下一个地址。

//arr[0] + 1  arr[0 + 1] 区别??????
//arr[0] + 1 表示数组中第一个元素的值加上1，而 arr[0 + 1] 表示数组中索引为1的元素的值。这两者是完全不同的操作。
//arr[0] + 1：表示取出数组中索引为0的元素的值，然后加上1。
//arr[0 + 1]：表示取出数组中索引为1的元素的值。
//例如，假设有一个数组 arr，其值为{ 3, 5, 7, 9 }：
//arr[0] + 1 的结果是 3 + 1 = 4。
//arr[0 + 1] 的结果是取出索引为1的元素的值，即 5。




//========二维数组名的解释
//
//int main()
//{
//	int arr[3][4];
//	//计算二维数组行数  48/16=3
//	int hang = sizeof(arr) / sizeof(arr[0]); //arr[0]表示第一行的大小，即列数乘以每个元素的大小。
//	//计算二维数组列数  16/4=4
//	int lie = sizeof(arr[0]) / sizeof(arr[0][0]);//arr[0][0]表示数组中一个元素的大小，通常情况下是 int 类型的大小。
//
//	int sz = sizeof(arr);//3*4=12元素   12*4字节=48
//	printf("%d", sz);
//	arr; //arr 存储的是数组的首地址，也就是第一行的地址。 二维数组名要想象成一维数组,每一行就是它的一个一维元素
//		 //二维数组可以看作是一系列一维数组的集合，每个一维数组代表二维数组的一行。
//
//	printf("%p\n", arr);    //000000000014FCC8
//	printf("%p\n", arr + 1);//000000000014FCD8  相差16个字节,跳过了一行
//	return 0;
//}








//9.数组的应用实例1:三子棋
//10.数组的应用实例2 : 扫雷游戏
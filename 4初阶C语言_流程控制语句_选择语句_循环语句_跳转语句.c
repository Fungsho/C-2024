
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h> 
#include <string.h>
//===================================分支语句和循环语句===================================
//一、分支语句
//	if
//	switch
//二、循环语句
//	while	循环的语法相对简单，只有一个条件判断部分
//	for		循环包含三个部分：for (初始化; 条件; 更新)表达式，结构更为紧凑  首先执行初始化部分
//	do while 
//三、转向语句
//	goto
//	break
//	continue
//	return
//什么是语句？ C语言可以分为以下五类
//	1、表达式语句
//	2、函数调用语句
//	3、控制语句
//	4、复合语句
//	5、空语句
//===================================控制语句，也叫分支语句
//用于控制程的执行序流程，以实现程序各种结构方式，它们由特定的语句定义符组成，C语言有九种控制语句。
//可分为三类：
//	1、条件判断语句也叫分支语句：if语句、switch语句；
//	2、循环执行语句：do while语句、while语句、for语句；
//	3、转向语句：break语句、goto语句、continue语句、return语句；
//C语言是结构化的程序设计语言。生活中所有的事物都可以抽象化成顺序、选择、循环结构或是组合；
//	1、顺序结构：是程序中最简单的结构，代码按照书写顺序依次执行，没有分支或循环。这种结构是默认的，不需要特别的控制语句。
//	2、选择结构：用于根据条件选择性地执行不同的代码块。
//	3、循环结构：循环结构用于重复执行一段代码，直到满足某个条件为止。

//===================================【if语句】第一种写法===================================
//int main()
//{
//	int age = 18;
//	if (age > 17) //if (布尔表达式)
//		printf("你成年了");
//	return 0;
//}

//【if语句】第二种写法
//int main()
//{
//	int age = 17;
//	if (age > 17) //if (布尔表达式)
//		printf("你成年了\n");
//		//printf("可以饮酒\n");	//这样写是不对的，if条件成立只会执行下面一条语句。如果执行多个语句，需要加上大括号
//								//上方的代码中，只有第一个 printf 语句是属于 if 语句的代码块。这是因为 if 语句默认只会执行紧随其后的
//								//一条语句，除非你使用了花括号{} 将多条语句组合成一个代码块。
//	else
//	{ 
//		printf("你未成年\n");	//花括号将它们括起来将多条语句组合成一个代码块
//		printf("不可以饮酒\n");	//便可执行多条语句
//	}
//	return 0;
//}

//【if语句】第三种写法，多分支（只会执行一个条件为真分支语句）
//在 if - else if - else 结构中，条件会按照顺序依次进行判断。如果某个条件为真，
//那么与该条件对应的代码块将被执行，而其余的代码块将被跳过。如果所有条件都为假，则执行 else 后面的代码块。
//int main()
//{
//	int age = 50;
//	scanf("%d", &age); //这里scanf 会读取用户输入内容，并将数据存储到指定的变量中。 这里就是根据取age内存地址，根据地址找到变量进行赋值的
//	if (age == 18)  //需要加圆括号表示优先计算age是否大于等于18，条件成立则为真。 
//		//条件表达式通常是放在圆括号 () 中的，某些情况可以不写但是不推荐。
//		printf("你成年了\n");
//	else if (age <= 17)
//		printf("你没有成年\n");
//	else if (60 <= age > 30) //这样写是不对的，它会先判断60是不是小于等于age=50, 结果60大于50结果为假，就是0再判断0是不是大于30.结果为假。
//		printf("错误的写法\n");
//	else if (age >= 30 && age <= 50) //正确的写法是使用逻辑操作符 && （并且）
//		printf("正确的写法你是中年人\n");
//	else //这个else可以不写，末尾 else 部分是可选的
//		printf("无法识别");
//	return 0;
//}
//详细分析一下 scanf 函数的工作原理：
//当你调用 scanf 函数时，你向它传递了一个指向你想要存储用户输入的变量的地址。例如，scanf("%d", &age); 中的& age 表示 age 变量的地址。
//scanf 函数内部会根据你提供的格式字符串（这里是 "%d"，表示读取一个整数），等待用户的输入。
//当用户输入一个整数后，scanf 函数会读取这个整数，并将它存储到你提供的地址中。它知道存储的位置是因为你提供了变量的地址。这个过程不涉及解引用，
//它只是根据地址找到变量，并将值写入到这个地址所对应的内存位置上。
//scanf 函数并不知道变量原来的值是什么，它只是根据你提供的格式字符串和变量的地址，从标准输入中读取数据，并将数据存储到指定的变量地址中。
//也就是说只有解引用操作符才可以获取内存变量的值
// 
//【悬空 else】 是指在一条 if 语句后面紧跟着一条 else 语句，而没有用花括号将 if 语句的代码块包裹起来的情况。
//int main()//代码不规范写法
//{
//	int a = 1;
//	int b = 2;
//	if (a == 1)
//		if (b == 1)//这样嵌套的if语句可以理解成 a等于10 且 b等于2 .是&& 并且的意思。
//			printf("这里不输出，因为条件不成立");
//	else //else 关键字将与最近的未匹配的 if 语句配对，即使存在多个 if 语句。并不是与谁对其就和谁匹配
//	printf("这里输出，因为我再嵌套if语句中，就近匹配原则，b等于1条件不成立，所以执行else否则语句");
//
//	return 0;
//}
//int main()//代码规范的写法。加上相应的圆括号花括号这样的符号，提升代码的美观性和可读性
//{
//	int a = 1;
//	int b = 2;
//	if (a == 1)
//	{
//		if (b == 1)
//			printf("aaa");
//		else
//			printf("bbb");
//	}
//	/*else
//		printf("ccc");*/
//}

//【if书写形式】推荐阅读《高质量的C-C++编程.pdf》代码规范的写法。加上相应的圆括号花括号这样的符号，提升代码的美观性和可读性
//代码的好坏不能用长度来衡量，不能一味的追求简化代码。
//变量命名（要规范、有意义）
//空格、换行、空行等缩进上的规范
//常量NAME
//大驼峰(类命名)Name
//小驼峰(方法命名)name
//等等还有很多

//int test(int r)  //格式不规范难以理解的写法。
//{
//	int a = 10;
//	if (a == 10)//条件成立
//		return 1;//在一个函数中，一旦执行了 return 语句，函数就会立即结束，并将指定的值返回给调用者。
//	return 0;
//}
//
//int hanshu(int r)  //规范的写法,这样就很好理解了。代码规范的写法。加上相应的圆括号花括号这样的符号，提升代码的美观性和可读性
//{
//	int a = 10;
//	if (a == 10)//条件成立
//		return 1;//在一个函数中，一旦执行了 return 语句，函数就会立即结束，并将指定的值返回给调用者。
//	else
//		return 0;
//}
//
//int main()
//{
//	int r = hanshu();
//	printf("%d\n", r);
//	return 0;
//}

//int main()//小例子,好代码的经验丰富写法。
//{
//	int a = 11;
//	if (a == 10)//这样写很容易少一个等号=，并且再代码调试的时候也不报错，会导致排错困难。
//				//这里要注意比较的内容是变量这样写才有意义
//		printf("%d\n", a);
//	else if (11 == a)//在使用等于操作符的时候，也就是说，只要符合语法，可以调换位置。来规避，只有等于操作符才可以这样书写。
//		printf("这样写如果少一个等号，调试就会报错，方便排错。");
//}

//【练习 判断一个数是否为奇数】
//判断是不是奇数
//int main()
//{
//	//初始化
//	int yu = 0;
//	//scanf("%d\n",&yu);//%d 表示要读取一个整数，而 \n 表示要读取一个换行符
//					  //这里要注意，用户需要先键入一个换行键，再输入数字。所以再单行输入的情况下不要加上\n
//	scanf("%d", &yu);
//	//判断是不是奇数 算法使用取模运算符 % 将 num 除以 2，得到余数。 1奇数 0偶数
//	if (yu % 2 ==1 )//这里要注意，yu%2是个表达式，所以不用颠倒来写，要不要写到左边取决于是不是变量
//		printf("yes");
//	else
//		printf("no");
//	return 0;
//}

//【输出1-100直接的奇数】。
//int main()  //第一种写法
//{
//	//初始化
//	int i = 1;
//	while (i <= 100)
//	{
//		//判断变量i是不是奇数
//		if (i % 2 == 1)
//			//条件成立说明是奇数，打印变量i
//			printf("%d\n", i);
//		//i自增
//		i = i + 1;
//	}
//	return 0;
//}
//int main()  //第二种写法 
//{
//	//初始化
//	int i = 1;
//	while (i <= 100)
//	{
//		printf("%d\n", i);
//		//i+2 因为从1进来是奇数，每次循环+2就是1，3，5，7，9，11 
//		//很巧妙的方式输出了1-100的奇数
//		//i = i + 2;
//		i += 2;  //+=赋值运算符，用于将右边的值加到左边的变量上，并将结果赋给左边的变量。
//				 //简化版的i=i+2
//	}
//	return 0;
//}

//=======================switch选择语句:开关语句 多条件选择的一种控制流结构===================================
//【switch(整形表达式)】   //整型数据类型通常用来存储整数值，而不包括小数部分
//匹配关键字：switch 、case、break


//siwtch语句写法 输出星期一到星期天
//int main()
//{
//	int day = 0;
//	scanf("%d", &day);
//	//对变量 day 的值进行多条件选择。
//	switch (day) //是一个开关语句，用于根据表达式的值在多个可能情况之间进行选择。
//	{
//	case 1:  //case标签，用于表示一个特定的情况或情况分支。每个 case 后面跟着一个常量，表示当表达式的值等于这个常量时，执行相应的代码块。
//		printf("星期一"); //这里需要注意，如果case 1条件成立，执行完会继续执行case 2 case 3才会停下来，因为 case3 中有break中断关键字
//	case 2:  //case后面必须是整形常量表达式 ,不能是变量,可以是字符，字符是特殊常量，它对应ASCII码
//		printf("星期二");
//	case 3: //要加冒号:这是语法规定。这个冒号的作用是分隔常量表达式与该 case 分支所对应的代码块。
//		printf("星期三");
//		break; //break 语句用于中断 switch 语句的执行，并跳出 switch 语句。
//	case 4:
//		printf("星期四");
//		break;
//	}
//	return 0;
//}
// 
//if 分支语句 选择语句的一种
//int main()
//{
//	int day = 0;
//	scanf("%d", &day);
//	if (1 == day)
//		printf("星期一");
//	else if (2 == day)
//		printf("星期二");
//	else if (3 == day)
//		printf("星期三");
//	else if (4 == day)
//	return 0;
//}

//小练习 输入1~3 输出aaaa 输入4~5输出bbb
//int main()
//{
//	int z = 0;
//	scanf("%d", &z);
//	switch (z)
//	{
//	case 1:	  //当case条件成立后,它会按照顺序依次执行,直到遇到break才会打断
//	case 2:	  //所以当输入1,2 都会执行到case3分支遇到break  这样写可节省代码量非常方便.
//	case 3:	  //每个 case 分支的结束都由 break 语句标记，这意味着当匹配到某个 case 后，执行完相应的代码后会退出 switch 语句，避免继续执行下一个 case 分支中的代码。
//		printf("aaaa");
//		break; //用于中断循环或者 switch 语句的执行，并跳出当前的循环或者 switch 语句块。
//	case 4:
//	case 5:
//		printf("bbbb");
//		break;  //编程好习惯,最好在最后一个case后面加上break,避免后续用到case导致错乱,看情况而定
//	}
//	return 0;
//}

//【default子句】默认值的意思。
//default 是在 switch 语句中可选的一个分支，用于处理 switch 表达式的值
//与所有其他 case 分支都不匹配的情况。当 switch 表达式的值不匹配任何一个 case 常量时，程序将执行 default 分支中的代码块。
//default用于处理:处理未知的输入或异常情况、提供默认的行为、编写防御性代码、处理不完整的枚举类型
//int main()
//{
//	int s = 0;
//	scanf("%d", &s);
//	switch (s)
//	{
//  //case(1>2):在 C 语言中，case 后面必须是常量表达式，而不是普通的逻辑表达式。因此，case 语句不能直接使用像 (1 > 2) 这样的逻辑表达式。
//	case 1:		//常量：不需要更改的数值、字符、字符串、日期、逻辑值、货币值等。
//	case 2:
//	case 3:
//		printf("aaaa");
//		break;
//	case 4:
//	case 5:
//		printf("vvvv");
//		break;
//	//默认值 switch可选的一个分支
//	default: //default 分支通常用于处理非预期的情况或者提供一个默认的行为。 和else有些类似
//		printf("输入有误");
//		break;  //编程好习惯，在每个switch语句中都放一条default子句是个好习惯，甚至可以在后面加上break;
//	}
//	return 0;
//}
//小练习，猜猜 m n的数值。
//int main()
//{
//	int n = 1;
//	int m = 2;
//	switch (n)
//	{
//	case 1:m++;
//	case 2:n++;
//	case 3:
//		switch (n) //switch语句可以嵌套使用
//		{			//switch 语句本身只是一种控制流程的语句，可以嵌套在其他循环或控制语句中
//		case 1:n++;
//		case 2:m++, n++;
//			break; //这个break只在当前作用域有效使用。所以跳出后，会继续运行case 4
//		}
//	case 4:	//在 case 分支中没有 break 时，程序会继续执行下一个 case 分支的代码。
//		m++;
//		break; //break 语句只在当前作用域内生效
//	default:
//		break;
//	}
//	printf("m=%d,n=%d\n", m, n);
//	return 0;
//}

//switch 语句和 if 语句都是用于控制程序流程的选择性语句，但它们之间有几个重要的区别：
//适用场景：
//switch 语句适用于在多个可能的情况之间进行选择，根据表达式的值执行相应的代码块。通常用于处理具有多个可能取值的整数或枚举类型。
//if 语句用于根据单个条件的真假选择性地执行代码块。通常用于处理布尔表达式或比较表达式。
//表达式类型：
//switch 语句中的表达式的值必须是整数或枚举类型，因为 case 分支用于匹配整数或枚举的常量值。
//if 语句中的条件可以是任意的布尔表达式，包括关系表达式、逻辑表达式、函数调用等。
//多重选择：
//switch 语句可以处理多个可能的情况，并根据表达式的值选择性地执行相应的代码块。
//if 语句只能处理两个可能的情况：当条件为真时执行一个代码块，当条件为假时执行另一个代码块。
//代码结构：
//switch 语句使用 case 分支来标记不同的情况，并通过 break 语句结束每个分支。
//if 语句没有类似 case 和 break 的语法结构，只需在条件为真时执行相应的代码块，否则执行 else 或后续的代码块。
//总的来说，switch 语句用于处理多个可能情况的选择性执行，而 if 语句用于根据单个条件的真假选择性执行代码块。选择使用哪种语句取决于具体的程序需求和逻辑结构。
//switch 和 if 在使用范围上有所不同，开发者应根据具体的逻辑需求和代码结构选择合适的语句来编写程序。

//关键字（keyword）和标识符（identifier）在编程语言中有着不同的含义和作用：
//关键字（keyword）：
//关键字是编程语言中预定义的具有特殊含义和用途的单词。
//它们通常用于表示语言的语法结构、控制流程、定义数据类型等方面。
//在程序中，关键字具有特殊的含义，不能被用作标识符（变量名、函数名等）。
//标识符（identifier）：
//标识符是程序员在编程时自定义的名字，用于表示变量、函数、常量等。
//标识符由字母、数字和下划线组成，但必须以字母或下划线开头，且不能是语言中的关键字。
//标识符用于表示程序中的各种实体，可以根据程序员的需要进行命名。


//=======================循环语句==============================
//while
//for
//do while 

//============while 循环语句
//"while" 条件循环，它是 C 语言中的一种循环控制语句，用于执行一个语句块，直到指定的条件为假为止。
//while (表达式)  ;匹配关键字：do   break   continue   goto
//	   循环语句;

//使用while语句打印1~10
//int main()
//{
//	int i = 1;
//	while (i <= 20)
//	{	
//		if (i == 11) //当i等于11条件成立
//		{ 
//			//break 在一些计算机编程语言中是保留字，其作用大多情况下是终止所在层的循环。
//			//1、break语句对if - else的条件语句不起作用。它主要用于循环语句  ，而if是分支语句。
//			//2、在多层循环中，一个break语句只向外跳一层。
//			break;	//跳出循环。 "break" 关键字主要用于循环结构中，但也可以在其他控制结构中使用比如 "switch" 语句中。
//		}			//break 语句并不会直接 “跳出” if 语句本身。相反，它会跳出它所在的 封闭嵌套块。
//					//在嵌套循环中，break 语句只能跳出当前所在的循环，而不会影响到外层的循环。
//		printf("%d", i);
//		i++;
//	}
//	return 0;
//}

//continue 流程控制语句， 用于在循环体中提前结束当前迭代，继续下一次迭代。
//  应用场景	循环中的条件判断、循环中的异常处理、循环中的性能优化
//int main()
//{
//	int i = 1;
//	while (i <= 15)
//	{
//		if (10 == i)
//		{
//			//跳过本次循环
//			continue; //continue 是一种控制语句，用于跳过当前循环中剩余的代码，直接进入下一次循环的迭代。
//					  //注意这里会陷入死循环。当i等于10的时候，if条件成立，执行continue ，跳过循环中的剩余代码，
//					  //也就是说i++不执行，i一直是10，如此往复，进入死循环。
//		}
//		printf("%d", i);
//		i++;
//	}
//	return 0;
//}
//获取字符
//getchar(): 它是个函数	 用于从标准输入流（通常是键盘）中读取一个字符。
			//函数没有参数。getchar() 函数会等待用户输入，并且在用户按下回车键之后才会读取输入的字符。
			//函数返回值是 int 类型 返回读取到的字符的 ASCII 码值（作为一个整数），如果读取到文件结束或者发生错误，则返回 EOF。
//输出字符
//putchar(): 它是个函数  你可以直接提供一个字符常量，也可以传递一个变量，甚至是表达式，只要表达式的结果可以被转换为字符类型。
			//总的来说，putchar() 函数的目的是将一个字符输出到标准输出流，并返回输出的字符或者出错标识（通常是EOF）
			//函数每次只能输出一个字符
//int main()
//{
//	//int ch = 0;
//	//while (getchar());
//	////getchar获取一个字符来自标准输入
//	//int ch = getchar();//要注意它的返回值类型是int类型
//	//printf("我是方式一%c\n", ch);//方法1打印字符
//	////输出字符
//	////putchar 函数接受一个字符作为参数，并将该字符输出到标准输出流中。它返回一个 int 类型的值，表示输出的字符，如果输出失败，则返回一个表示错误的负值。
//	//putchar(ch);//方法2输出字符 函数会将参数转换为对应的 ASCII 字符，并将该字符输出到标准输出流
//	int ch = 0;
//	while ((ch = getchar()) != EOF)	//这里注意，getchar()有返回值，所以要带上括号,(ch = getchar())这是一个整体表达式，所以括起来了。
//									//EOF 是一个在C语言中定义的常量，表示文件结束符（End Of File）不是一个有效的字符，它的值一般被定义为-1
//									//所以!=EOF,就说明输入的是一个正常字符.
//		putchar(ch);//在打印过程中为什么自动换行,getchar()在获取输入过程中,中间有个【输入缓冲区】当用户键盘输入内容a按下回车时候,键入的内容会送到输入缓冲区.
//					//输入缓冲区里面就会有:a\n  两个字符用户输入的字符一个字符是a一个字符是\n 回车键
//					//这时候getchar()在从输入缓冲区中得到一个字符(因为它只能输出一个字符) 打印了一个a,因为是while循环,缓冲区还有一个\n,所以进行了换行操作.
//					
//		//如何停止打印呢,可以在调试窗口按ctrl+z 意思就是返回一个EOF
//	return 0;
//}
// 

//getchar()函数使用案例:
//int main()
//{
//	char psw[20] = { 0 };//数组本来就是个地址,所以不用取地址
//	printf("请输入密码:>");
//	scanf("%s", psw); //scanf  getchar 都是一样的都要等待输入缓冲区的内容如果
//					  //scanf函数不会忽略用户输入的回车码。它会像读取其他字符一样读取回车码，并将其放入输入缓冲区。
//					  //scanf函数通常用于读取特定格式的数据，因此它会跳过一些空白字符，包括空格、制表符和换行符。
//					  //所以输入缓冲区会留下一个用户输入的回车键\n 被跳过了 
//	printf("确认密码Y/N");
//	int queren = getchar();//由于前面输入的内容都被scanf拿走了,输入缓冲区只剩下了一个\n
//	if ('y' == queren) //   \n不等于 y所以执行else
//		printf("密码设置完成\n");
//	else
//		printf("取消\n");
//	return 0;
//}

//int main() //尝试解决
//{
//	char psw[20] = { 0 };
//	printf("请输入密码:>");
//	scanf("%s", psw); 
//	getchar();	//这里是解决上面,scanf留下的\n问题,利用这个getchar()取走,这样下面就可以正常执行了.
//				//不过这个方式很笨,是个临时方案.
//				//如果用户输入了adb dsa这个情况,scanf因为只读取特点字符,遇到空格 换行会停下来,
//				//这时候还会剩下一个空格 dsa,
//	printf("确认密码Y/N:");
//	int queren = getchar();
//	if ('y' == queren)
//		printf("密码设置完成\n");
//	else
//		printf("取消\n");
//	return 0;
//}
//原因分析：
//scanf 函数的工作原理是根据格式化字符串来解析输入数据。每个格式化说明符都对应一种数据类型，并负责读取该类型的数据。
//当 scanf 函数遇到一个字符时，它会将其与格式化字符串中的相应格式化说明符进行匹配。
//如果匹配成功，则将该字符解析为对应的数据类型，并将其存入指定的变量。
//如果匹配失败，或者遇到空格、制表符或换行符等空白字符，则 scanf 函数会认为当前格式化说明符所指定的数据已读取完毕，并停止读取。

//int main()//继续完善
//{
//	char psw[20] = { 0 };
//	printf("请输入密码: ");
//	scanf("%s", psw); //scanf()输入函数 读取密码，包括换行符
//	int ch;
//	while ((ch = getchar()) != '\n') 
//					
//	{ 
//		// 消耗了输入缓冲区中的当前字符包括换行符
//		//为什么很费解\n为什么被拿走了,因为,getchar()是先从输入缓冲区拿走\n字符,在进行循环条件判断是不是等于\n
//		//因此,输入缓冲区的\n也被取走. 便可继续执行下面的命令.
//				
//	}
//	printf("确认密码 (Y/N): ");
//	int queren = getchar(); // 读取确认字符
//
//	if (queren == 'Y') 
//	{
//		printf("密码设置完成\n");
//	}
//	else {
//		printf("取消\n");
//	}
//}


//练习题 转换以下ASCII码为对应字符并输出他们。73, 32, 99, 97, 110, 32, 100, 111, 32, 105, 116, 33
//int main()
//{
//	//int arr;//这样是错的， 你只定义了 int arr;，这只是一个单独的整型变量，并不是一个数组。
//	int arr[] = { 73, 32, 99, 97, 110, 32, 100, 111, 32, 105, 116, 33 };  //12个4字节=48个字节这里是int类型 需要用sizeof
//	int i = 0;
//	//sizeof(arr)-计算的是所有数组的总大小，单位是字节。
//	//sizeof(arr[0])-计算的是数组中第一个元素的大小，单位是字节。
//	//通过将整个数组的大小除以单个元素的大小，你可以得到数组中元素的个数。
//	int cc = sizeof(arr);
//	printf("%d\n", cc);//12*4=48数组总共有48个字节 
//	int sz = sizeof(arr) / sizeof(arr[0]);  //这里需要牢记。
//	printf("%d\n", sz);//12个元素   48/4=12
//	while (i < sz)
//	{
//		printf("%c", arr[i]);
//		i++;
//	}
//	return 0;
//}
//可以使用strlen(求字符串长度)吗？？？？
//strlen 函数用于计算字符串的长度，但是它不能直接用于计算整型数组的长度，
//因为整型数组和字符串是不同的类型。strlen 函数只能用于以 null 结尾的字符串（即以 '\0' 结尾的字符数组），
//它会计算数组中从第一个字符开始直到遇到 null 字符的长度。
//strlen 函数会在遇到空格、换行符或者任何其他非 null 字符时停止计算字符串的长度。
//它只会计算从字符串的起始位置开始直到遇到 null 字符（'\0'）为止的长度。


//BC14 出生日期输入输出  
//得到需求后，要仔细分析。无非就是输入输出，拆分输入，拆分输出.
//int main()
//{
//	//输入过程---得到年月日
//	int year;
//	int month;
//	int day;
//	//int kong 是scanf()返回值,如果不加编译器会提示,所以加上,这个变量是可以忽略的,只是解除提示的做法.
//	int kong=scanf("%4d%2d%2d", &year, &month, &day);	//%4d, 指定域宽输入,也就是4个整形字符,将这个字符赋值到内存变量year中.
//														//%2d, 指定域宽输入,也就是2个整形字符,将这个字符赋值到内存变量month中.
//														//%2d, 指定域宽输入,也就是2个整形字符,将这个字符赋值到内存变量day中.
//	
//	//输出过程---
//	printf("year:%4d\nmonth:%02d\ndate:\%02d\n", year, month,day);
//	//输出拆分
//	printf("year:%4d\n", year);		//%4d, 指定域宽输出,也就是4个整形字符
//	printf("month:%02d\n", month);  //在十进制表示中，整数的开头的 0 是没有意义的，它不会改变整数的值。
//	printf("date:%02d\n", day);		//如果你想要打印 01，以保留开头的零，可以使用 % 02d 这样的格式控制符
//	printf("date:%2d\n", day);		//如果是01 ,只会打印空格填充域宽和一个1,所以要用%0格式控制符,它会按照指定的宽度进行打印，不足的地方用零填充
//	return 0;
//}


//BC11 学生基本信息输入输出
//int main()
//{
//    int id = 0;
//    float c = 0.0f;  //这里如果不加f ,编译器默认是double类型双浮点
//    float shuxue = 0.0f;
//    float yingyu = 0.0f;
//    int sc = scanf("%d;%f,%f,%f", &id, &c, &shuxue, &yingyu);//要对应需求中的输入格式.
//    //%.2f 保存小数点后两位的意思
//    printf("The each subject score of No. %d is %.2f, %.2f, %.2f.", id, c, shuxue, yingyu);//要对应要求中的输出格式.  
//    return 0;
//}

//浮点数相关知识
//当涉及到单精度和双精度浮点数时，主要区别在于它们的精度和表示范围：
//单精度浮点数（float）：
//使用 32 位来表示。
//精度约为 7 到 8 位有效数字。
//能够表示的范围大约是 10 ^ (-38) 到 10 ^ 38 之间。
//双精度浮点数（double）：
//使用 64 位来表示。
//精度约为 15 到 16 位有效数字。
//能够表示的范围大约是 10 ^ (-308) 到 10 ^ 308 之间。
//总的来说，双精度浮点数具有更高的精度和更大的表示范围，因此通常在需要更高精度或更大范围的数值计算时使用。
//然而，双精度浮点数也占用更多的内存空间，因此在内存和性能有限的情况下，可以使用单精度浮点数来节省资源。


//反斜杠 \ 是转义字符的开始标志，用于表示后面紧跟的字符或字符序列是需要特殊处理的。通常情况下，反斜杠后面可以跟一个或多个字符来进行转义。
//int main()
//{
//	printf("printf(\"asda\\n\")\n");
//	return 0;
//}

//BC123 小乐乐找最大数
//小乐乐获得4个最大数，请帮他编程找到最大的数。
//一行，一个整数，为输入的4个整数中最大的整数。
//输入：5 8 2 5  输出：8
//找出最大的数
//int main()
//{
//    // 定义一个整型数组，用于存储用户输入的四个整数
//    int arr[4] = { 0 };
//    int i = 0;
//
//    // 使用循环读取用户输入的四个整数，并存储到数组中
//    while (i < 4)
//    {
//        // 提示用户输入一个整数，并将其存储到数组的相应位置
//        scanf("%d", &arr[i]);
//        i++;
//    }
//
//    // 假设第一个输入的整数为最大值
//    int max = arr[0];
//    i = 1;
//
//    // 使用循环遍历数组中的每个元素，找出最大值
//    while (i < 4)
//    {
//        // 如果当前元素大于假设的最大值，则更新最大值为当前元素的值
//        if (arr[i] > max)
//        {
//            max = arr[i];
//        }
//        i++;
//    }
//
//    // 打印输出找到的最大值
//    printf("The maximum value is: %d", max);
//
//    return 0;
//}


//太绕了,,每一步都打印
//又陷入逻辑误区了,归根到底还是没有熟悉各个关键字的执行原理. 一定要清楚代码每一步执行了什么.
//scanf("%d") 每次只获取一个整数, 并不是我所想的那样输入5343,被分成4次拿走. 
//既然这样就好理解,先拿走一个初识值作为一个条件假设,后面通过循环3次,每次跟第一次拿走的值进行比较,条件成立就把值给到max,循环三次也就是做了三次比大小.
//int main() {
//
//    int xunhuan = 1;
//    int zuidazhi = 0;
//    int max = 0;
//    scanf("%d", &max);  // 第一次取值给变量max
//    while (xunhuan < 4) {  // 循环3次取剩下三个值
//        scanf("%d ", &zuidazhi);  // 获取字符
//        if (max < zuidazhi) {  // 用第一次取的值进行判断是否小于
//            max = zuidazhi;  // 如果小于，把值给max
//        }
//        xunhuan++;  // 自增
//    }
//    printf("%d\n", max);
//    return 0;
//}

//BC27 计算球体的体积
//int main()
//{
//    double shuru = 0.0; //变量一定要初始化,不然就是个随机值,注意变量的数据类型.
//    double v = 0.0;
//    scanf("%lf", &shuru);
//    v = 4 / 3.0 * 3.1415926 * shuru * shuru * shuru;  //如果除法想得到小数4/3必须又一个是小数,不然就会变成整数,导致计算错误.
//    printf("%.3lf", v); //这里%lf用来表示双精度浮点数
//    return 0;
//}
//BC25 计算体重指数
//int main()
//{
//    //输入
//    int tizhong = 0;
//    int shengao = 0;
//    scanf("%d %d", &tizhong, &shengao);
//
//    //计算BMI指数，体重公斤除以身高米数平方
//    float bmi = tizhong / ((shengao * 0.01) * (shengao * 0.01));
//    printf("%.2f", bmi);
//    return 0;
//}


//===============================for循环================================
//最常用的循环  用于重复执行一段代码直到满足某个条件  支持多个变量
//for (初始化表达式; 循环条件; 更新(调整)表达式) 
//{
//	// 循环体
//}
//初始化表达式（Initialization Expression）： 在循环开始之前执行的一条语句，通常用于初始化循环控制变量。这个表达式只会执行一次。
//循环条件（Loop Condition）： 在每次循环迭代开始之前都会被求值的一个表达式。如果该表达式的值为真（非零），则执行循环体；如果为假（零），则退出循环。
//更新表达式（Update Expression）： 在每次循环迭代结束之后执行的一条语句，通常用于更新循环控制变量的值。
//循环体（Loop Body）： 在循环中要执行的语句块，可以包含任意数量的语句，这些语句会重复执行直到循环条件变为假。
//匹配可选关键字 continue; break;

//for循环语句打印1~100
//int main()
//{
//	int i = 0;
//	for (i = 1; i <= 100; i++)
//		printf("%d ", i);  //for默认只跟一条语句执行,如果想要执行多条语句,需要加上花括号{}
//	return 0;
//}
//int main()
//{
//	int i = 0;
//	for (i =0; i <= 100; i++)
//	{
//		if (5 == i)
//			continue;  //跳过本次循环不执行作用域后面的代码,会执行for循环语句的表达式3, i++
//
//		printf("%d ", i);
//	}
//		
//	return 0;
//}
//建议,不要再for循环体内修改循环变量,防止for循环失去控制.
//建议,for语句的循环控制变量的值采用"前闭后开区间"写法.
//int main() //前闭后开写法  闭表示包含边界的值   开表示不包含边界的值
//{
//	int i = 10;
//	for (i = 0; i < 10; i++); //0 1 2 3 4 5 6 7 8 9 开表示不包含边界的值10
//		printf("aaa");
//	return 0;
//}
//int main() //两边都是闭区  
//{
//	int i = 10;
//	for (i = 0; i <= 9; i++);
//	printf("aaa");
//	return 0;
//}  //没太懂,不过不重要


///为什么i==0,可以执行  ,因为是比较结果，对于结果的判断。
//要区分，是逻辑表达式，还是比较表达式 
//逻辑表达式：在逻辑表达式中，变量的值直接用来表示真（true）或假（false）。在C语言中，任何非零值都被视为真，而0被视为假。
//比较表达式：比较表达式涉及比较两个值（例如，使用 == 、<、>等比较运算符）。这种表达式的结果是一个布尔值：如果比较为真，则结果为1（真），如果比较为假，则结果为0（假）。
//我们比较number的值是否等于0。由于number确实是0，比较结果为真
// 
//在 C 语言以及其他大多数编程语言中，逻辑表达式（如 if 语句的条件部分）中的 0 通常被视为逻辑假（false），
//非零值（包括正数和负数）则被视为逻辑真（true）。然而，这里提到的 0 作为逻辑值与 int i = 0; if (i == 0) 中的 0 是两个不同的概念：
//逻辑值： 在逻辑表达式中，如 if (condition)，condition 被评估为一个逻辑值（true 或 false）。如果 condition 是一个整数值，0 被视为 false，非零值被视为 true。例如：
//int x = 0;
//if (x) { /* 这里不会执行，因为 x 为 0，视为 false */ }
//等值比较： 在等值比较表达式中，如 if (i == 0)，i 与 0 之间进行的是数值上的等价性判断。
//这里的 0 不是作为一个逻辑值出现，而是作为与变量 i 进行比较的另一个数值。如果 i 的值恰好等于 0，比较结果为真（true），if 语句的条件成立，执行其后的大括号{} 中的代码块。例如：
//int i = 0;
//if (i == 0) { /* 这里会执行，因为 i 等于 0 */ }
//总结来说，int i = 0; if (i == 0) 中的 0 是作为数值参与等值比较的，与逻辑表达式中的 0 表示逻辑假是两个不同的概念。
//在这种情况下，由于 i 的值就是 0，所以 if (i == 0) 的条件成立，对应的代码块会被执行。


//============一些for循环的变种
//int main()
//{
	//for循环的判断部分省略意味着,判断恒(永远)成立.
	//for (; ;) //始终为真  死循环  不建议这样省略  会导致嵌套循环错乱.
	//	printf("hhhh");

	////for (int i = 0; i < 10; i++)这样写法,是C99标准才支持,会导致不支持这个标准的编译器,无法编译. 
	//for (int i = 0; i < 10; i++)
	//	printf("aaa");

	//正确写法
	//int i = 0;
	//for (int i = 0; i < 10; i++)
	//{
	//	printf("aaa");
	//}	

	//使用多个变量控制循环  for支持多变量
//	int x, y;
//	for (x = 0, y = 0; x > 2 && y < 5; x++, y++)
//	{
//		printf("aaa");
//	}
//	return 0;
//}
//请问循环要循环多少次????
//int main()
//{
//	int i = 0;
//	int k = 0;
//	for (i = 0, k = 0; k = 0; i++, k++)  //这里第二个表达式 k=0是赋值,0为假,所以条件不成立.不执行.
//										//要弄清楚,赋值还是条件判断
//		k++;
//	return 0;
//}

//====================do while() 循环   
//循环体至少会被执行一次  匹配关键字 break  continue
//语法结构
//do
//	循环语句;
//while (表达式);
//do - while 循环是 C 语言中的一种循环结构，它与 while 循环类似，但是它的循环条件在循环体执行之后判断。这意味着无论循环条件是否成立，循环体至少会被执行一次。

//打印1~100
//int main()
//{
//	int i = 1;
//	do
//	{
//		if (i == 50)
//		{
//			break;
//		}
//		if (i == 49)
//		{
//			continue;  
//		}
//		printf("%d ", i);
//		i++;
//	}	
//	while (i<=100);
//	return 0;
//}



////=======================================================循环训练 上
//计算n的阶乘  阶乘符号 “!” 是数学中用来表示阶乘的符号。阶乘通常定义为一个正整数 n 和所有小于它的正整数的乘积
//写代码：先想解决办法（编程思维），再写代码（按照编程语法去写）
//阶乘公式：n!= n × (n-1) × (n-2) × … × 2 × 1
//或者是 n!= 1 × 2 × 3 × … ×(n - 1) × n
//int main()
//{
//	//首先了解阶乘公式 例如 5的阶乘 = 1*2*3*4*5
//	//因此可以使用循环方式,那么就需要,第一个循环变量
//	//用户需要输入一个指定的数字计算阶乘,第二个输入变量
//	//需要计算过程,第三个计算变量
//	
//	//初始化变量
//	int xh = 1;//从1开始
//	int sr = 0;//这个输入变量来做循环的条件判断 
//	int js = 1;// 这里注意, 计算是先从1开始的所以是1 ,当然也可是5,通过xh--;方式
//	//获取输入
//	scanf("%d", &sr);
//	//利用循环计算
//	for (xh = 1; xh <= sr; xh++) //从1
//	{
//		js = js * xh;//给js一个1用于循环计算,如果是0,导致0*任何数都0.  如果用户输入5,那就循环五次每次结果赋值给js就是阶乘了.
//	}
//	printf("%d", js);
//
//
//	return 0;
//}

//计算 1!+2!+3!...+10! 的结果
//分析题目
//把1~10的阶乘相加.


//1计算 n的阶乘
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	int i = 0;
//	int j = 1;//首先将阶乘结果初始化为1，因为任何数的阶乘的初值都是1。
//	for (i = 1; i <= n; i++)
//	{
//		j *=  i;  //j=j*i
//	}
//	printf("%d", j);
//	return 0;
//}
//利用for循环的特性, 通过用户输入的数,来当作循环条件.来决定循环几次.
//每次循环自增1,并把每次循环的结果赋值给j,实现阶乘的计算公式.
//三个变量共同协作，实现了利用循环计算整数n的阶乘的功能。


//2计算1-10阶乘得和   第一种写法  代码较少的方式
//int main()
//{
//	//先循环10次
//	int i = 1;  //循环初始化
//	int jie = 1;//阶乘初始化
//	int he = 0; //相加初始化
//	for (i = 1; i <= 10; i++)
//	{
//		//计算阶乘
//		jie = jie * i;
//		//计算相加
//		he = he + jie;
//	}
//	printf("%d", he);
//}

//2计算1-10阶乘得和   第二中写法,嵌套循环  (非常绕脑子..表示吃不消了)
//int main()
//{
//	//首先我要循环得到阶乘 已知计算1-10
//	//把他们加起来
//	int j1 = 1;
//	int i = 0;
//	int he = 0;
//	int ii = 0;
//	for(ii=1;ii<=10;ii++)
//	{
//		j1 = 1; //重置 j1 为1，否则，j1 会一直累积乘积，导致结果错误。
//		for (i = 1; i <= ii; i++)
//		{
//			j1 = j1 * i;  //注意j1 是每次相乘结果给自身赋值 也就是1~10每次相乘就是10的阶乘
//		}
//		he = he + j1;
//	}
//	printf("%d", he);
//	return 0;
//}

//2计算1-10阶乘得和   第三中写法,while
//int main()
//{
//	int i = 1;
//	int c = 1;
//	int x = 1;
//
//	while (i <= 10)
//	{	
//		x = x * i;
//		c = c + x;
//		i++;
//	}
//	printf("%d", c);
//	return 0;
//}

//3在一个有序数组中查找具体数字n
//int main()  //这种查找有序数组的方法有点笨,不适用大量元素的查找. 
//{
//	//有序数组可以按照不同的排序规则来排列元素  如递增 递减  或其他特定的顺序
//	int arr[] = { 1,3,5,7,9,11,13,15,17,19 };   
//	//计算数组总数
//	int szi = sizeof(arr) / sizeof(arr[0]);
//	int zhao = 13; //找整数1
//	int i = 0;
//	//遍历数组
//	for (i = 0; i <= szi; i++)
//	{
//		if (arr[i] == zhao)  //arr[i] 用的是循环的变量,从0开始对应数组下标0
//		{
//			printf("数组中的索引为 %d\n",i);//输出 ar索引 为6  对应的元素是 13
//			break;
//		}	
//		if (i == szi)
//		{
//			printf("没了\n%d", i); 
//		}
//	}
//	return 0;
//}


//二分查找 折半查找   缺点,必须是有序数组
//一些技巧, 中间值 <n 就忽视左边   大于>n忽视右边.
//int main()
//{
//    // 声明并初始化数组 arr 和变量 k
//    int arr[] = { 1,3,5,7,9,11,13,15,17,19 };
//    int k = 19;
//
//    // 计算数组 arr 的长度
//    int szdx = sizeof(arr) / sizeof(arr[0]);
//
//    // 初始化二分查找的左右指针
//    int zuo = 0;
//    int you = szdx - 1;
//
//    // 初始化中间指针 zhong
//    int zhong = 0;
//
//    // 使用二分查找算法查找 k 在数组中的位置
//    // 如果 k 存在，找到它的索引；如果不存在，则返回找不到
//    while (zuo <= you)
//    {
//        // 计算中间索引
//        zhong = (zuo + you) / 2;  //这里有溢出风险,因为在较大的数组情况下,两个值相加有溢出风险,所以需要进一步处理.
//
//        // 如果中间元素小于 k，则将左指针移动到中间元素的右侧
//        if (arr[zhong] < k)  // 这里注意,我要知道数组元素是什么,所以要用它的索引来找,在去跟k比较
//        {
//            zuo = zhong + 1;
//        }
//
//        // 如果中间元素大于 k，则将右指针移动到中间元素的左侧
//        else if (arr[zhong] > k)
//        {
//            you = zhong - 1;
//        }
//
//        // 如果中间元素等于 k，则找到了 k，打印索引并退出循环
//        else
//        {
//            printf("找到了%d", zhong);
//            break;
//        }
//    }
//
//    // 如果循环结束时左指针大于右指针，说明 k 不在数组中，打印找不到
//    if (zuo > you)
//    {
//        printf("找不到了");
//    }
//
//    return 0;
//}
//总结, 二分查找,就是在平均值那个位置,做判断, 就像一根线反复对折的过程.
//这个程序使用了二分查找算法，这是一种在有序数组中查找特定元素的效率很高的算法。
//二分查找每次将搜索范围减半，因此时间复杂度为 O(log n)，其中 n 是数组的长度。这种算法特别适用于大量数据的查找操作。






//===============把数学公式代码化 有什么技巧吗  当涉及到算数方面,应该先可视化,先去找规律, 利用这些条件,总结规律总结办法.. 在去设计代码.
//思维误区, 循环语句,最重要的就是要循环多久,要先明确循环的次数,把需求中的关键信息与循环相关的找出来,并且先定义次数是干什么的.
//当涉及到算数方面,应该先可视化,先去找规律, 利用这些条件,总结规律总结办法.. 在去设计代码.
//循环很重要的变量 i 一般都会参与计算过程,所以要将 i 也带入到公式中.


//这里没学懂需要多复习,实现多种写法
//https://www.bilibili.com/video/BV1Vm4y1r7jY?p=36&vd_source=f7ddcd601961a1fdf039e8aebf4558fa





//=======================================================循环训练 中
//在一个有序数组中，查找某个数字。 有序数组:元素按照一定的顺序排列的数据结构
//首先在数组中找某个数，他的数组包括很多元素，这样的话，我就需要知道数组中的所有元素对应的内容。
//第一步，获取数组元素个数
//第二步，遍历数组 ，可以使用循环。
//第三步，判断内容
//第四步，输出结果
//int main()
//{
//	//初始化数组  数组本身是个地址:数组名被解释为指向数组首元素的指针   指针可以理解为存储内存地址的变量。
//	int arr[] = { 1,3,5,7,9,11,13,15,18,21,23 };
//	//获取元素个数 sizeof运算符，用于获取数据类型或变量在内存中所占的字节数。sizeof运算符可以用于确定数组在内存中占用的总字节数，但它并不能直接告诉数组中有多少个元素。所以通过总字节除以单个元素字节得出元素个数
//	int ysgs = sizeof(arr) / sizeof(arr[0]);
//	printf("元素个数:%d\n", ysgs);
//
//	//获取用户输入,指定要查找的值 scanf():读取输入数据的函数。
//	printf("请输入要寻找的内容:");
//	//int shuru =scanf("%d", &shuru);//注意这样写会导致 scanf函数返回的值赋给了shuru,  一定要仔细区分. shuru等于的是scanf,就代表是取的函数返回值.
//								  //想要存储输入这俩变量是两回事,
//								  // int shuru =scanf("%d", &shuru);一个是函数返回变量,
//								  // scanf("%d", &shuru)一个是取变量地址传参.
//	int shuru = 0;//初始化 用于存放输入的内容
//	scanf("%d", &shuru);//scanf 函数的格式字符串应该只包含格式说明符，用于指定要读取的数据类型，而不应该包含额外的文本。
//	
//	//遍历数组(通过数组索引第一个下标0开始遍历,等于变量ysgs即完成遍历)
//	 int i = 0;
//	 while (i <= ysgs)
//		 //判断内容,因为通过数组变量i,i初始值为0对应数组索引第一个下标. 每次循环经过i变量依次判断
//		 if (arr[i] == shuru)
//		 {
//			 printf("找到了下标是:%d", i);  //arr[i] 数组索引
//			 break; //跳出循环
//		 }
//		 else
//		 {
//			 i++;//循环自增
//			 printf("自增:%d\n", i);  //否则 i自增
//		 }		 
//	return 0;
//}

//学习笔记,在定义变量的适合 ,一定要区分写法,
// int shuru =scanf("%d", &shuru);一个是函数返回变量,
// scanf("%d", &shuru)一个是取变量地址传参.
//在函数变量前面定义和单独定义的区别. 一种是把函数返回值 通常是0  1 赋值给了变量
//一种是把函数操作过程得到的结果赋值给变量. 

//二分查找法,复习.
//通过折半查找方式,提高查找效率, 这种写法只适用于有序数组.
//int main()
//{
//	//1创建有序数组:
//	int arr[] = { 1,3,5,7,9,11,13,15,18,20,23 };
//	//2获取输入内容
//	int shuru = 0;
//	scanf("%d", &shuru);
//
//	//3二分查找搜索算法
//	//二分查找特点,通过首尾平均值与被找值比较,缩小待搜索区间的范围，重新确定左右边界。
//	//因此需要三个变量, 首(左)变量,尾(右)变量,平均值(中间)变量.
//	int zuo = 0; //左边起始位置变量
//	int you = sizeof(arr) / sizeof(arr[0]) - 1;//sizeof 不是函数,所以可以这样写表达式,如果是函数需要注意,会把函数返回值给了you变量.
//											   //计算数组中元素的个数:数组内存总字节除以元素字节得到元素个数.
//											   // -1是因为右边取的是数组下标的值,因为数组是从0开始的,要减去1,对应数组最右边的下标.
//	//int zhong = (zuo + you) / 2;//计算中间值,注意表达式的优先级,用括号表示先加减在乘除.
//	//4判断比较中间元素
//	//if (zhong == shuru)
//	//{
//	//	printf("找到了他的下标是%d他的值是%d\n", zhong, arr[zhong]);
//	//}
//	//else if (zhong < shuru) //如果中间元素小于目标值，则目标值可能在中间元素的右侧，更新左边界
//	//{
//	//	zuo + 1;
//	//}
//	//else if (zhong > shuru)//如果中间元素大于目标值，则目标值可能在中间元素的左侧，更新右边界
//	//{
//	//	you - 1;
//	//}
//	
//	//5将算法进行循环整理.
//	int i = 0;
//	for (i=0; zuo <= you &&i<=you; i++)  //重复查找：直到搜索范围缩小到为空或者找到目标值为止。
//	{
//		int zhong = (zuo + you) / 2;  //这里犯错误了, 因为写在循环外,导致zhong变量一直没发生变化.导致无法更新寻找范围.
//		//if (zhong == shuru) 这里注意,这是一个很不易察觉的错误, 变量zhong 存的是数组下标值,shuru是目标值, 所以要加上索引才行,这样才可以跟元素内容比较.
//		if(arr[zhong]==shuru) //这里逻辑一定要清晰,不要混乱. 要把比较内容区分清晰要比较的是数组索引还是数组元素;
//		{
//			printf("找到了他的下标是%d他的值是%d\n", zhong, arr[zhong]);
//			break;//跳出循环
//		}
//		else if (arr[zhong] < shuru) //如果中间元素小于目标值，则目标值可能在中间元素的右侧，更新左边界
//		{
//			//zuo += 1;//这里又犯错了, zuo变量zuo的初始值,要更新zuo的值 应该要用zhong的值 刷新范围
//			//逻辑要清晰,每写一步想一想这样做的结果是什么..形成编程思维
//			zuo=zhong + 1;
//		}
//		else if (arr[zhong] > shuru)//如果中间元素大于目标值，则目标值可能在中间元素的左侧，更新右边界
//		{
//			you = zhong - 1;
//		}
//		else
//		{
//			break;
//		}
//		//else(zuo > you)  //else 后面不能直接跟圆括号条件。通常情况下，else 后面应该跟一个代码块，用于在前面的 if 条件不满足时执行的代码。
//		//{
//		//	printf("找不到你输入的内容");
//		//}
//	}
//	if (zuo > you) //左边是起始位置, 左右边界是缩小的过程,如果左边大于右边说明越界了,那么这个范围就是无效的
//	{
//		printf("找不到你输入的内容");
//	}
//	return 0;
//}
//虽然写出来了,但是过程还是有不少错误,需要反复练习.
#include <stdio.h>

//int main() 
//{
//    // 给定的有序数组
//    int arr[] = { 1, 3, 5, 7, 9, 11, 13, 15, 18, 20, 23 };
//    int shuru = 0;
//
//    // 输入要查找的整数值
//    printf("请输入要查找的整数值：");
//    // 输入合法性验证
//    if (scanf("%d", &shuru) != 1) 
//    {
//        printf("输入的不是有效的整数值\n");
//        return 1;
//    }
//
//    // 初始化左右边界
//    int zuo = 0; // 左边界
//    int you = sizeof(arr) / sizeof(arr[0]) - 1; // 右边界
//    int zhong; // 中间位置
//
//    // 二分查找循环
//    while (zuo <= you) 
//    {
//        // 计算中间位置
//        //zhong = (zuo + you) / 2;  //这里考虑到超大量数据的时候溢出的风险,需要换个算法
//        zhong = zuo + (you - zuo) / 2; //安全方式求平均值
//        // 如果找到目标值，输出位置并返回
//        if (arr[zhong] == shuru) 
//        {
//            printf("找到了，下标是%d，值是%d\n", zhong, arr[zhong]);
//            return 0;
//        }
//        // 如果中间值小于目标值，则在右半部分继续查找
//        else if (arr[zhong] < shuru) 
//        {
//            zuo = zhong + 1; // 更新左边界为中间位置的右侧
//        }
//        // 如果中间值大于目标值，则在左半部分继续查找
//        else {
//            you = zhong - 1; // 更新右边界为中间位置的左侧
//        }
//    }
//
//    // 循环结束仍未找到目标值，输出未找到提示
//    printf("找不到你输入的内容\n");
//    return 0;
//}

//二分查找,可以理解成 把一组数 从中间分开,用中间值判断左右,从而丢弃一半, 把剩余的数组,在进行折半,以此类推
//遇到算法问题,先用图形方式体现出来,或者手写 总结规律


//演示多个字符从两端移动,向中间汇聚.
//huanying guanglin!!!
//####################

#include <windows.h>  //包含sleep函数不同操作系统头文件名字不同,需要注意.
#include <stdlib.h>	//包含system函数 用于在操作系统中执行系统命令
//int main()
//{
//	//初始化数组内容
//	char arr1[] = "huanying guanglin!!!";//只有字符数组可以不加花括号
//	char arr2[] = { "####################" }; //他类型的数组（如整数数组、浮点数数组等），初始化时必须使用花括号{}
//	//计算数组元素个数
////	int yuansu = sizeof(arr1) / sizeof(arr1[0]);//会统计字符数组中隐藏的\0 结束标志
//	int you2 = strlen(arr2) - 1;//也可以用strlen函数求字符长度.不计算\0  它取的是字符串的总长度,所以不需要在除以单个元素..要跟sizeof区分一下.
//	//左右边界索引下标
//	int zuo = 0;		 // 注意区别\n 换行 \0 空字符 
//	//int you = yuansu - 2;//因为是下标,从0开始要-1,其次字符数组有个隐藏\0
//	//int you2 = yuansu2 - 1;//两种计算方式的区别 strlen函数方式没有额外统计,减去1得到下标即可.
//	//循环打印
//	//如何让它们实现换位置显示出来?...
//	//我想复杂了,,其实就是输入arr2, 把arr1左右两边的值锁定到arr2对应的位置就行了.
//	while (zuo <= you2)
//	{
//		arr2[zuo] = arr1[zuo];
//		zuo++;
//		arr2[you2] = arr1[you2];
//		you2--;
//		printf("%s\n", arr2); //这里注意,上面值都锁定好了,所以在打印得时候,会按照上面锁定得值打印arr2 得到替换得效果.
//		Sleep(500);//睡眠(暂停)500毫秒   注意区分大小写
//		//是在 Windows 平台上用于清空命令行窗口的命令。 
//		system("cls");
//	}
//	printf("%s\n", arr2); //屏幕被system("cls")清空,在补充一行
//	return 0;
//}

//总结,区分转义字符\n   \0
//	转义字符\n 换行符,getchar()会等待用户输入字符，直到用户按下回车键（Enter）才会停止。同时在输入缓冲区遇到\n 便会停下来.
//	转义字符\0 空字符,strlen()函数是用于计算以空字符 '\0' 结尾的字符串的长度的函数。遇到空字符 \0 时，会停止计算字符串的长度
//strlen 与sizeof 区分
//strlen它取的是字符串的总长度, 所以不需要在除以单个元素..
//sizeof运算符获取的是数据类型或变量占据的存储空间大小，以字节为单位 ,如果求元素个数需要进行除以元素..




//模拟用户登录场景,只允许输入三次密码错误.密码正确则提示登录成功,失败三次程序退出.
//int main()
//{
//	//假设密码是abcdef
//	//设定3次循环
//	int i = 0;
//	char mima[20] = { 0 };
//	for (i = 0; i < 3; i++)
//	{
//		printf("请输入密码:");
//		scanf("%s", mima);//数组本身就是地址,指向第一个元素得内存地址.
//		//if (mima == "abcdef") //这里错误了,比较两个字符串是否相等,不能使用==,
//		if(strcmp(mima,"abcdef")==0)//要使用库函数:strcmp()返回0则相等
//									//strcmp用于比较两个字符串的大小 ASCII 码值进行比较 可以是数字标点符号
//		{
//			printf("登录成功\n");
//			break;
//		}
//		else
//		{
//			printf("密码错误\n");
//		}
//	}
//	if (i == 3)
//	{
//		printf("3次密码错误程序退出\n");
//	}
//
//	return 0;
//}



//使用函数设计一个小游戏，随机产生1~100整数。
//根据用户选择，提示猜大了，猜小了。
//******************************************
//******************************************
//****************1开始游戏 ****************
//****************2结束游戏 ****************
//******************************************
//******************************************

//设计思路,产生随机数 1~100
//根据用户输入的数字判断猜大猜小的提示
//游戏流程控制,1开始2结束.猜对结束,猜错次数.
//void 菜单选择()
//{
//	//printf("***************************\n");
//	//printf("***************************\n");
//	//printf("*******1开始游戏***********\n");
//	//printf("*******0退出游戏***********\n");
//	//printf("***************************\n");
//	//printf("***************************\n");
//	//或者这样打印
//	printf("***************************\n***************************\n*******1开始游戏***********\n*******0退出游戏***********\n***************************\n");
//
//}
//
//#include <time.h>
//void 猜大小()
//{
//	int 随机数 = 0;
//	//int 菜单选择 = 0;
//	int 输入 = 1;
//	int 输入次数 = 0;
//	//RAND_MAX; //RAND_MAX 不是函数，而是 C 标准库 <stdlib.h> 中定义的一个宏。它是一个常量，表示在使用标准库函数 rand() 生成随机数时可能返回的最大值。
//	//1.生成随机数
//	//srand(100);//播种 如果使用相同的种子,则产生相同的随机数序列,随后rand 的调用将使用此新的内部状态，与使用默认状态相比，产生不同的随机数序列。
//	//int 随机数=rand(); //函数，用于生成伪随机数。 函数返回一个介于 0 和 RAND_MAX 之间
//	//printf("这是根据内部公式生成的随机数%d\n", 随机数);
//	//printf("seed(种子)设置此内部状态的初始值%d\n", 随机数);
//	//2.利用时间戳
//	//time_t timer = NULL;//NULL空指针
//	//timer = time(NULL);//获取当前时间的时间戳并存储在 timer 变量中
//	//printf("这是time:%ld\n", timer);  //%ld   long int    %lld  long long int
//	//将当前时间作为种子传递给随机数生成器。 圆括号中是srand函数参数的表达式，取当前时间戳作为种子。
//	//srand((unsigned int) time(NULL)); //因为srand函数希望返回的数据类型是无符号整形。所以（强制转换数据类型）表达式
//	//随机数 = rand(); //主函数中以通过srand函数设置了rand的种子为当前时间.
//	//printf("当前时间戳%ld\n", 随机数);
//	
//	//3.数值范围设置
//	随机数 = rand() % 100 + 1;  //因为rand随机数范围是0~32767,我们的需求是猜1~100之间的数字.通过取余数范围规定在1~100.
//							   //+1是对取余数的结果进行加1操作,如果是0加1就是1 所以实现的1~100 
//	int 猜 = 0;
//	
//	for (输入次数 = 1; 输入次数 <= 20; 输入次数++)
//	{
//		//4.判断大小
//		printf("请猜测数字1~100\n");
//		scanf("%d", &猜);
//
//		if (输入次数 == 20)
//		{
//			printf("game over\n");
//			break;
//		}
//		if (随机数 == 猜)
//		{
//			printf("恭喜你猜对了\n");
//			printf("你用了:%d就猜对了\n", 输入次数);
//			break;
//		}
//		else if (随机数 < 猜)
//		{
//			printf("猜大了");			
//			printf("你用了:%d次没猜对\n", 输入次数);
//		}
//		else if (随机数 > 猜)
//		{
//			printf("猜小了");		
//			printf("你用了:%d次没猜对\n", 输入次数);
//		}
//
//	}
//}
//
//
//int main()
//{
//	int 菜单输入 = 0;
//	//这行代码的作用是初始化随机数生成器的种子	srand() 函数用于设置 rand() 函数使用的随机数种子
//	srand((unsigned int)time(NULL)); //明白了 ,这里是将当前时间值作为了种子.作为初始化,执行一次后,影响rand生成的序列
//	//直接用do while主循环
//	int 开关 = 1;//循环条件为真（即非零） 用于控制whle开关. 也可以用菜单输入的值来控制do开关,
//	do 
//	{
//		//设计菜单
//		菜单选择();//这里就是直接打印个菜单,写在前面 do每次循环都会打印一次菜单.
//		printf("请选择菜单:");
//		scanf("%d", &菜单输入);
//		//循环判断选择的菜单,是否正确
//		switch (菜单输入)  //switch语句并不会一直循环执行,他是分支的控制语句
//		{
//		case 1:
//		{
//			printf("进入游戏\n");//
//			猜大小();//进入猜大小函数, 使用这个函数中的逻辑实现猜大小功能.
//			break;
//		}
//		case 0:
//		{
//			printf("结束游戏进程\n");
//			开关 = 0;//用于控制whle开关. 也可以用菜单输入的值来控制do开关,
//			//int 开关 = 0; 这样写是不对的,这相当于声明了一个局部变量,只在case0标签中有作用,出了作用域就销毁了
//			break;//程序会立即跳出当前的循环或 switch 语句 所以要在前面写赋值等操作
//		}
//		default: //相当于else ,用户输入的值与case不匹配,用于未知操作的一种处理方法.避免后续case的执行.
//		{
//			printf("输入的内容与case不匹配,初始化请重新选择\n");
//			break;
//		}
//		}
//	} while (开关);
//	
//	return 0;
//}



//=====================goto语句 流程控制语句
// "goto"语句本身并不受代码顺序的影响，它可以跳转到任何被标记的位置，无论这些位置在代码中的哪个位置。
// 不能夸函数跳转
//C语言中提供了可以随意滥用的 goto语句和标记跳转的标号。
//从理论上 goto语句是没有必要的，实践中没有goto语句也可以很容易的写出代码。
//但是某些场合下goto语句还是用得着的, 最常见的用法就是终止程序在某些深度嵌套的结构的处理过程。
//例如：一次跳出两层或多层循环。
//多层循环这种情况使用break是达不到目的的。它只能从最内层循环退出到上一层循环.
//语法结构
//int main()
//{
//	goto 我是标记2;
//我是标记1:
//	{
//		printf("哈哈哈哈");
//	}
//我是标记2:
//	{
//		printf("呵呵呵呵");
//	}
//	goto 我是标记1;
//	return 0;
//}
//这段代码通过流程控制语句goto 标记; 实现跳转.
//进入主函数,goto 我是标记2 会执行 我是标记2下面的代码;
//标记2 执行完会顺序执行后面的代码, goto 标记1, 此时 先执行标记1 下面代码后执行后面的代码
//标记1 标记2 执行完再次goto 标记1 ,以此循环. 
//goto语句不易维护,可读性差尽量少用.
//但在深度嵌套循环中有其使用场景.
//例如:
//int main()
//{
//	for (;;)
//	{
//		for (;;)
//		{
//			for (;;)
//				goto 我是标记1; //在这种多层循环的情况下,如果使用break 要用多个来跳出循环,而用goto 可直接结束多层循环的执行.
//		}
//	}
//我是标记1:
//	printf("即使不用break通过goto 标签直接来到此处");
//	return 0;
//}

//改造使用goto语句的关机程序. 不用goto方式实现.
//1.电脑运行起来后,10分钟自动关机
//2.如果输入:"我是猪"	就取消关机 否则关机
//int main()
//{
//	//存储输入
//	char arr[20] = { 0 };
//	//关机命令
//	system("shutdown -s -t 600");
//再来一次:  //跳转标签
//	printf("请输入\"我是猪\"取消关机\n");
//	//用户输入
//	scanf("%s",arr); //数组本身就是地址首个元素的..
//	//if (strcmp(arr, "我是猪"))  这里注意,strcmp函数有返回值,相等为0   str1<str2 为负数  str1>str2 为正数.
//	if (strcmp(arr, "我是猪") == 0)
//	{
//		//取消关机命令
//		system("shutdown -a");
//	}
//	else
//		goto 再来一次;//跳转到标签再来一次
//	return 0;
//}
//改造 去除 goto
//int main()
//{
//	char arr[20] = {0};
//	//关机命令
//	system("shutdown -s -t 600");
//	while (1)
//	{
//		//关机提示
//		printf("计算机将在10分钟内关闭,请输入\"我是猪\"取消关机\n");
//		//输入提示
//		printf("请输入:");
//		scanf("%s", arr);
//		//判断输入
//		if (strcmp(arr, "我是猪")==0)
//		{
//			//取消关机
//			system("shutdown -a");
//			break;
//		}
//	}
//	return 0;
//}







//在复习
//1.
//模拟用户登录场景, 只允许输入三次密码错误.密码正确则提示登录成功, 失败三次程序退出.
//2.
//使用函数设计一个小游戏，随机产生1~100整数。
//根据用户选择，提示猜大了，猜小了。
//3.
//演示多个字符从两端移动,向中间汇聚.
//huanying guanglin!!!
//####################
//4.
//在一个无序数组中，查找某个数字。
//5.
//在有序数组查找某个数字,二分查找
//6.
//猜大小
//7.
//goto语句
//8.
//自动关机


//注意事项
//数组作为参数时，实际上传递的是数组的首个元素的地址。这是因为在C语言中，数组名被视为指向数组第一个元素的指针。
//如果你想传递特定的数组元素，你可以传递数组名以及元素的索引，然后在函数中使用这个索引来访问相应的元素。
//严格写法要用指针变量接收* 但传递的也是地址 所以x86 是4 x64是8字节
// 
//default: default 关键字主要用于 switch 语句中
//处理未知情况：default用于处理未被显式列出的情况。当switch表达式的值与所有case标签都不匹配时，程序会执行default标签下的代码块。这可以确保程序在遇到未知情况时有一个明确的行为，而不会产生未定义的行为。
//提供默认操作：default还可以用于提供一个默认的操作或响应。即使在其他情况下，你可能已经考虑到了所有可能的情况，但是添加一个default标签可以作为一个安全保障，以防出现意外情况。
// 
//switch:语句并不会一直循环执行,他是分支的控制语句
// 
//switch 中的break (虽然switch是多路分支的控制语句,而break主要用于循环语句,但可以防止继续执行的这么一个效果)
//主要是为了防止“贯穿”效果，即继续执行下一个case标签中的代码。在switch语句中，
//如果不使用break语句，程序会执行当前case标签下的代码块，并继续执行下一个case标签中的代码，直到遇到break语句或者switch语句结束。

//break;程序会立即跳出当前的循环或 switch 语句 不会在执行后面的语句,如果有赋值判断操作需要在break前面写

//continue 关键字不能直接用在 switch 语句中 因为switch是多路分支选择语句

//do while 循环  先循环,在判断, 至少会执行一次.
//do - while 循环是一种后测试循环，它会先执行循环体内的代码，然后再检查循环条件。
//如果循环条件为真（即非零），则继续执行循环体内的代码，否则结束循环，继续执行循环之后的代码。
//do while()圆括号是指定循环的条件表达式, 这个语句不带返回值

//强制转换（Casting）: 使用强制转换运算符(type) expression 显式转换值。例如，(float) 123 将 int 转换为 float。
//要加上圆括号表达式。 (数据类型)表达式

//调用 srand((unsigned int)time(NULL)) 函数是为了给随机数生成器提供一个种子，以便初始化它。
//这个种子决定了随机数生成器产生的随机数序列。通常情况下，如果你在程序中只调用一次 srand 函数，
//并且种子是基于当前时间计算的，那么在程序的后续调用中，随机数生成器将使用相同的种子来生成随机数序列，从而产生相同的输出。

//srand((unsigned int)time(NULL)) 作用： 这行代码的作用是初始化随机数生成器的种子。通过将当前时间的时间戳转换为 unsigned int 类型，
//并传递给 srand 函数，你可以确保每次程序运行时，都会使用不同的种子值来初始化随机数生成器。因此，即使程序多次运行，每次都会生成不同的随机数序列。
//rand() 函数的随机数序列： 一旦种子被 srand 函数初始化，后续调用 rand() 函数将会基于这个种子值生成随机数序列。这个序列实际上并不是事先预先生成好的，
//而是根据种子值在每次调用 rand() 函数时动态生成的。每次调用 rand() 函数，都会生成一个新的随机数，但是这些随机数之间之间的关系是由种子决定的。
//因此，调用 srand((unsigned int)time(NULL)) 一次可以确保每次程序运行时都会使用不同的种子值，从而产生不同的随机数序列。

//种子的概念:可以是时间戳作为种子. 这个时间戳并不是具体的数字,也不是数组什么的, 就是把当前时间作为种子
//除了时间戳之外，还有许多其他的值可以作为种子来初始化随机数生成器，例如：
//用户输入： 用户提供的任何数据，例如键盘输入、鼠标点击、文件内容等，都可以作为种子。
//系统状态： 系统状态或环境变量的值，例如系统时间、进程 ID、内存使用情况等，都可以作为种子。
//硬件信息： 例如处理器温度、网卡流量、磁盘使用情况等硬件信息，都可以作为种子。
//其他随机源： 有些系统提供了特定的随机源，例如 / dev / random 和 / dev / urandom 设备在 Unix / Linux 系统中可以用来生成随机数，这些随机数可以作为种子。
//用户自定义数据： 用户可以定义任何自己选择的数据作为种子，例如某个特定的配置文件内容、网络请求结果、传感器数据等等。
//总的来说，种子可以是任何数据，只要它具有足够的随机性和唯一性，以确保生成的随机数序列是不可预测的。

//取余数.随机数 = rand() %100 + 1;  为什么结果是1~100
//由于取模运算后得到的是 0 到 99，为了将范围扩展到 1 到 100（包含两端点），需要对结果加上 1。这样，原本的 0 变成了 1，1 变成 2，依此类推，99 变成了 100。




//=====================新知识点
//头文件 #include <windows.h>
//Sleep()函数 睡眠意思 单位毫秒.
//头文件 <stdlib.h>
//system()函数 执行操作系统命令
//strcmp()函数 字符串比较  用于比较两个字符串的大小 ASCII 码值进行比较 可以是数字标点符号
//如果第一个字符串小于第二个字符串，则返回一个负数；如果第一个字符串大于第二个字符串，则返回一个正数；如果两个字符串相等，则返回 0。

//rand(); 函数，用于生成伪随机数。 函数返回一个介于 0 和 RAND_MAX【32767】之间的整数.int类型 stdlib.h 头文件
//RAND_MAX 不是函数，而是 C 标准库 <stdlib.h> 中定义的一个宏。它是一个常量，表示在使用标准库函数 rand() 生成随机数时可能返回的最大值。通常是【32767】
//为什么rand()生成随机数会重复.
//rand函数是一种用于生成伪随机数的函数。其原理是基于线性同余法。如果需要真正随机数，可以使用硬件随机数生成器或加密散列函数。
//rand函数是一个伪随机数生成器，它使用一个称为种子的内部状态来生成随机数。
//每次调用rand函数时，都会使用当前的种子生成一个新的随机数。如果在两次调用rand函数之间没有改变种子，则两次生成的随机数可能会相同。
//种子（seed）是一个起始值或输入，用于初始化随机数生成器的内部状态。

//srand() 函数用于设置 rand() 函数使用的随机数种子
//srand()函数,没有返回值 参数 seed: 用于播种随机数生成器的无符号整数值。不同的种子将产生不同的随机数序列。
//本身不生成随机数，它只会影响rand生成的序列。
//使用相同的种子将始终产生相同的随机数序列。
//rand使用基于当前内部状态的数学公式生成伪随机数。
//srand根据提供的seed设置此内部状态的初始值。
//随后对rand的调用将使用此新的内部状态，与使用默认状态相比，产生不同的随机数序列。

//time()  --------<time.h>
//time函数是C语言中用于获取当前时间的函数。它返回从1970年1月1日00:00 : 00（格林尼治时间）到当前时间的秒数。
//参数说明
//timer：可选指针参数，用于存储当前时间。如果timer为NULL，则函数返回值不存储。
//返回值
//如果成功，则函数返回从1970年1月1日00 : 00 : 00（格林尼治时间）到当前时间的秒数。
//如果失败，则函数返回 - 1。
//time函数的用途
//获取当前时间，用于日志记录、计时等操作。
//生成随机数种子。
//将时间转换为其他格式，例如年月日时分秒。
//time函数的注意事项
//time函数返回的秒数是基于格林尼治时间（GMT）的。如果需要获取本地时间，需要进行时区转换。
//time函数返回的时间精度取决于系统的计时器精度。
//在使用time函数之前，需要包含time.h头文件。

//time_t 是 C 语言中用于表示时间的数据类型。它存储从一个基准时间点开始经过的秒数。
//time_t 被定义为一个整数类型（例如 long 或 int）typedef time_t  long long更大整数的数据类型
//存储类型
//time_t 是一个 算术类型，具体的大小和有符号 / 无符号的属性取决于实现的系统。
//32 位有符号整数：在这种情况下，time_t 的最大值可以表示到 2038 年 1 月 19 日 03:14 : 07 UTC 之前的时间。
//32 位无符号整数：如果使用无符号整数，则最大值可以表示到 2106 年 左右的时间。
//64 位有符号整数：在 64 位系统中，time_t 可以表示范围更广的时间，理论上可以涵盖数千年的时间跨度。

//unsigned 无符号数据类型
//unsigned 关键字不仅仅可以用于定义无符号整数类型，还可以用于定义无符号字符、短整型、长整型等不同数据类型。

//goto语句
//"go to"语句本身并不受代码顺序的影响，它可以跳转到任何被标记的位置，无论这些位置在代码中的哪个位置。

//shutdown头文件<stdlib.h>用于在程序中执行系统命令
//shutdown 是一个系统命令，用于关闭计算机或者重新启动计算机。
//shutdown / s: 关闭计算机。
//shutdown / r : 重新启动计算机。
//shutdown / s / t 600 : 在 600 秒后关闭计算机。
//shutdown / r / t 3600 : 在 3600 秒后重新启动计算机。

//strcmp  头文件<string.h>比较两个字符串
//如果 str1 小于 str2，则返回一个负数。
//如果 str1 大于 str2，则返回一个正数。
//如果两个字符串相等，则返回 0。


//system 函数用于在程序中执行系统命令
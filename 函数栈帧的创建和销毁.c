#define _CRT_SECURE_NO_WARNINGS 1
//===================================前期学习的时候，我们可能有很多困惑？===========================================
//比如：
//●局部变量是怎么创建的 ?
//●为什么局部变量的值是随机值 ?
//●函数是怎么传参的 ? 传参的顺序是怎样的 ?
//●形参和实参是什么关系 ?
//●函数调用是怎么做的 ?
//●函数调用是结束后怎么返回的 ?
//知道和函数栈帧的创建和销毁就都会了，其实就是修炼了自己的内功，也能搞懂后期更多的知识。
//进入正题.
//今天讲解的时候，使用的环境是VS2013, 不要使用太高级的编译器，越高级的编译器，越不容易学习和观察。
//同时在不同的编译器下，函数调用过程中栈帧的创建是略有差异的，具体细节取决于编译器的实现。


////===================================寄存器===========================================
//这些寄存器在x86架构的CPU中扮演着不同的角色，主要用于存储数据、地址或者控制信息。以下是它们的主要作用：
//EAX（累加器寄存器）：
//EAX是一个通用寄存器，常用于存放算术运算的结果，函数返回值也通常存放在EAX中。
//EBX（基址寄存器）：
//EBX也是一个通用寄存器，它经常被用作指向数据的指针，或者存放一些临时变量。
//ECX（计数器寄存器）：
//ECX通常用于循环计数，例如在字符串操作或者数组操作中用于循环次数的计数器。
//EDX（数据寄存器）：
//EDX是一个通用寄存器，用于存放一些运算结果的高位或者扩展位。
//EBP（基址指针寄存器）：
//EBP通常用于指向栈帧的基址，用于访问当前函数的局部变量和参数。
//ESP（堆栈指针寄存器）：
//ESP用于指向当前栈顶的地址，主要用于处理函数调用时的栈操作。
//这些寄存器在程序执行过程中起着重要的作用，用于存储数据、地址和控制信息，以及在函数调用和程序执行过程中进行数据传递和存储的操作。

//函数栈帧----每一个函数调用，都要在栈区创建一个空间。
//EBP，ESP这2个寄存器中存放的是地址。
//这2个地址是用来维护函数栈帧的。

//																						-------------------------低地址
//int add(int x, int y)//																|						|
//{//																					|						|
//	int z = 0;//																		|						|
//	z = x + y;//																		|						|
//	return z;//																			|						|
//}//																					|						|
////																					|						|
////esp  栈顶指针--------------------------------										|						|
//int main()							//esp和ebp										|						|
//{									//中间区域											|						|
//	int a = 0;						//就是为:											|						|
//	int b = 0;						//main函数											|------------------------\esp
//	int c = 0;						//开辟的的											|						| \
//		c = add(a, b);					//函数栈帧										|		add函数			|  >栈帧
//	printf("%d\n", c);				//栈区的习惯是先使用高地址,在使用低地址.			|						| /
//	return 0;						//内存是从高地址向低地址蔓延的						|						|/ebp
//}									//调用哪个函数esp,ebp就去维护哪个函数的函数栈帧.	|------------------------
//ebp  栈低指针----------------高地址													|		main函数		|
//																				   ebp-8|		cccccccc		| 栈帧开辟
//																				   ebp-4|		cccccccc		|
//在VS2013中,main函数也是被其他函数调用的										ebp	    |------------------------
//main																					|__tmainCRTStartup函数	| 栈帧
//__tmainCRTStartup																		|------------------------
//mainCRTStartup																		|mainCRTStartup函数		| 栈帧
//																						|------------------------
//mainCRTStartup函数调用__tmainCRTStartup函数											|						|
//__tmainCRTStartup函数调用main函数.													|						|
//																						-------------------------高地址

//寄存器是集成到cpu上的跟内存是独立关系的.

//push 压栈:给栈顶创建一个元素
//pop  出栈:从栈顶删除一个元素

//压栈操作（push）将数据压入栈中，每次都将新的数据元素放置在栈顶。

//push ebp 指令会将 ebp 寄存器的值压入内存的具体地址，即栈顶位置。栈是一段内存区域，通常位于进程的虚拟内存空间中。当执行 push ebp 指令时，ebp 寄存器的值被写入到栈顶位置所指向的内存地址中。
//具体来说，栈顶位置由栈指针寄存器 esp 指向，执行 push ebp 指令后，esp 寄存器的值会减小，指向新的栈顶位置。而 ebp 寄存器的值则被写入到原来的栈顶位置所指向的内存地址中，即压入了栈顶位置。
//这样做的目的是为了保存上一个函数的基址指针，以便在函数执行过程中能够访问上一个函数的局部变量和参数。

//push ebx  push esi 如果两条指令 它们会指向同一个地址吗？
//它们分别将 ebx 和 esi 寄存器的值压入栈中。这两个指令执行后，压入栈中的值会被存储在栈的不同位置，因为栈是一个后进先出（LIFO）的数据结构，每次压栈操作都会使栈指针 esp 向低地址方向移动。

//如果栈顶已经被占用（即栈顶指针 esp 指向的位置已经有数据），那么 push 操作会将新的数据放置在栈顶的上方，即栈顶指针 esp 的值会向下移动，以指向新的空闲位置。
//在 x86 架构中，栈是向下生长的，即栈顶的地址是较低的地址，栈底的地址是较高的地址。因此，执行 push 操作时，栈顶指针 esp 的值会减小，指向新的空闲位置，这样新的数据就会被放置在栈顶的上方。

//push 操作会将数据压入栈顶，同时栈顶指针 esp 的值会自动减小，指向新的栈顶位置。这是因为栈是向下生长的，即栈顶的地址是较低的地址，栈底的地址是较高的地址。